<!--
// CHANGE: Что изменилось
// CHANGE: - Добавлен переключатель режима карты с сохранением выбора.
// CHANGE: - Реализован выбор зон и детальный ИИ-объезд с обходными точками.
// CHANGE: - Обновлены рекомендации с подсказками из выбранных зон.
// CHANGE: - Обновлён шэринг с поддержкой via-точек в Яндекс.Навигаторе.
// CHANGE: - Удалены функции GPX и геолокации.
// CHANGE: - Настроен гибридный слой по умолчанию и очистка detour-маршрутов.
// CHANGE: - Улучшена обработка зон и пересечений маршрута.
// CHANGE: - Уточнена логика голосовых подсказок и подсветки шагов.
// CHANGE: - Добавлены вспомогательные функции для расчёта обходных точек.
-->
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Маршруты для грузовиков</title>
  <!-- встроенный favicon с грузовиком, чтобы убрать 404 -->
  <link
    rel="icon"
    type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%20viewBox%3D%270%200%2064%2064%27%3E%3Crect%20x%3D%276%27%20y%3D%2720%27%20width%3D%2734%27%20height%3D%2720%27%20rx%3D%274%27%20fill%3D%27%231b6cff%27%2F%3E%3Crect%20x%3D%2740%27%20y%3D%2726%27%20width%3D%2714%27%20height%3D%2714%27%20rx%3D%273%27%20fill%3D%27%230f4ec2%27%2F%3E%3Ccircle%20cx%3D%2720%27%20cy%3D%2744%27%20r%3D%276%27%20fill%3D%27%230f172a%27%2F%3E%3Ccircle%20cx%3D%2746%27%20cy%3D%2744%27%20r%3D%276%27%20fill%3D%27%230f172a%27%2F%3E%3C%2Fsvg%3E"
  />
  <style>
    :root {
      color-scheme: light;
      --accent: #1b6cff;
      --accent-dark: #0f4ec2;
      --danger: #ff3b30;
      --warning: #ff9500;
      --sheet-bg: rgba(255, 255, 255, 0.94);
      --panel-bg: rgba(255, 255, 255, 0.92);
      --shadow: 0 18px 44px rgba(15, 23, 42, 0.18);
      --font: "Inter", "Segoe UI", Roboto, sans-serif;
      --border: rgba(15, 23, 42, 0.08);
    }

    *, *::before, *::after { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      font-family: var(--font);
      background: #f3f4f8;
      color: #0f172a;
      -webkit-font-smoothing: antialiased;
    }

    body {
      position: relative;
      min-height: 100dvh;
      overflow: hidden;
      padding-bottom: env(safe-area-inset-bottom);
    }

    #map {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #loading {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(15, 23, 42, 0.35);
      color: #fff;
      font-size: 16px;
      z-index: 2000;
    }

    .panel {
      position: fixed;
      z-index: 1100;
      background: var(--panel-bg);
      box-shadow: var(--shadow);
      border-radius: 18px;
      padding: 12px 14px;
      backdrop-filter: blur(18px);
      transition: opacity 0.3s ease, transform 0.3s ease;
      max-width: min(320px, calc(100vw - 32px));
      max-height: 35vh;
      overflow: hidden;
    }

    .panel.hidden { opacity: 0; pointer-events: none; }

    #recommendations {
      top: calc(16px + env(safe-area-inset-top));
      left: 16px;
      width: min(320px, calc(100vw - 32px));
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 35vh;
      overflow-y: auto;
    }
    #recommendations.hidden { transform: translateY(-24px); }
    #recommendations h2 { margin: 0; font-size: 16px; font-weight: 700; }
    #recommendationsList {
      margin: 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 14px;
    }

    #legend {
      top: calc(16px + env(safe-area-inset-top));
      right: 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 0;
      font-size: 14px;
      width: min(320px, calc(100vw - 32px));
      max-height: 35vh;
      overflow-y: auto;
    }
    #legend.hidden { transform: translateY(-24px); }
    #legend h2 { margin: 0; font-size: 16px; font-weight: 700; }
    .legend-item { display: grid; grid-template-columns: 22px 1fr; align-items: center; gap: 12px; }
    .legend-icon { width: 16px; height: 16px; border-radius: 999px; }
    .legend-icon.red { background: var(--danger); }
    .legend-icon.orange { background: var(--warning); }
    .legend-line { width: 24px; height: 4px; border-radius: 999px; background: var(--accent); }
    /* // CHANGE: Компактный селектор режима карты */
    .map-mode-control { display: flex; flex-direction: column; gap: 6px; font-size: 13px; }
    .map-mode-control label { font-weight: 600; }
    .map-mode-control select {
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.95);
      padding: 8px 10px;
      font: inherit;
      color: inherit;
    }

    .sheet {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      z-index: 1200;
      background: var(--sheet-bg);
      border-radius: 26px 26px 0 0;
      box-shadow: 0 -18px 48px rgba(15, 23, 42, 0.35);
      padding: 16px 16px calc(24px + env(safe-area-inset-bottom));
      display: flex;
      flex-direction: column;
      gap: 14px;
      max-height: 35vh;
      transition: transform 0.35s ease;
      backdrop-filter: blur(20px);
      overflow: hidden;
      overflow-y: auto;
    }
    .sheet.hidden { transform: translateY(calc(100% - 72px)); }
    .sheet::before {
      content: ""; width: 58px; height: 5px;
      background: rgba(15, 23, 42, 0.25);
      border-radius: 999px; align-self: center; margin-top: -4px;
    }

    form { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .field { display: flex; flex-direction: column; gap: 6px; }
    .field label { font-size: 13px; font-weight: 600; }
    .field input {
      padding: 12px 14px; border-radius: 12px;
      border: 1px solid var(--border);
      font-size: 15px; background: rgba(255, 255, 255, 0.95);
      color: inherit;
    }
    .field input:focus { outline: 2px solid rgba(27, 108, 255, 0.35); outline-offset: 1px; }

    .toggles {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px; font-size: 13px;
    }
    .toggles label {
      display: flex; align-items: center; gap: 8px;
      padding: 8px 10px; border-radius: 10px;
      background: rgba(15, 23, 42, 0.06);
    }

    .actions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
    }
    button { font-family: var(--font); }
    .actions button {
      padding: 12px; border-radius: 14px; border: none;
      font-size: 14px; font-weight: 600; cursor: pointer; color: #fff;
      background: var(--accent);
      box-shadow: 0 12px 30px rgba(27, 108, 255, 0.25);
      min-height: 44px;
      transition: transform 0.16s ease, box-shadow 0.16s ease, background 0.16s ease;
    }
    .actions button.secondary { background: #1f2937; box-shadow: 0 12px 30px rgba(15, 23, 42, 0.25); }
    .actions button.danger { background: var(--danger); box-shadow: 0 12px 30px rgba(255, 59, 48, 0.25); }
    .actions button:active { transform: translateY(1px); box-shadow: none; }

    .steps {
      border-radius: 16px; background: rgba(15, 23, 42, 0.06);
      padding: 10px 14px 14px; max-height: 160px; overflow-y: auto;
    }
    .steps[hidden]{ display:none; }
    .steps h3 { margin: 0 0 10px 0; font-size: 15px; font-weight: 700; }
    .steps ol { margin: 0; padding-left: 18px; display: flex; flex-direction: column; gap: 8px; font-size: 14px; }
    .steps li.active { color: var(--accent-dark); font-weight: 600; }

    @media (min-width: 768px) {
      #recommendations { max-height: 35vh; }
      .sheet {
        width: min(320px, 32vw); left: auto; right: 24px; bottom: 32px;
        border-radius: 26px; max-height: 35vh;
      }
      .sheet.hidden { transform: translateY(calc(100% - 88px)); }
      .sheet-toggle { bottom: calc(32px + env(safe-area-inset-bottom)); }
    }
  </style>
  <script src="https://api-maps.yandex.ru/2.1/?apikey=292c3277-6b44-4b1d-88db-813ff4caa159&lang=ru_RU"></script>
</head>
<body>
  <div id="map"></div>
  <div id="loading" hidden>Загрузка...</div>

  <button type="button" class="panel-toggle" id="legendToggleBtn" style="position:fixed;left:16px;top:8px;z-index:1300;">Скрыть легенду</button>
  <button type="button" class="panel-toggle" id="recommendationsToggleBtn" style="position:fixed;left:160px;top:8px;z-index:1300;">Скрыть рекомендации</button>
  <button type="button" class="panel-toggle sheet-toggle" id="sheetToggleBtn" style="position:fixed;right:16px;bottom:8px;z-index:1300;">Свернуть панель</button>

  <section id="recommendations" class="panel">
    <h2>Рекомендации</h2>
    <ul id="recommendationsList">
      <li>Постройте маршрут, чтобы получить рекомендации по рейсу.</li>
    </ul>
  </section>

  <aside id="legend" class="panel">
    <h2>Легенда</h2>
    <div class="legend-item"><span class="legend-icon red"></span> <span>Весовые рамки</span></div>
    <div class="legend-item"><span class="legend-icon orange"></span> <span>Платон</span></div>
    <div class="legend-item"><span class="legend-line"></span> <span>Основной маршрут</span></div>
    <!-- // CHANGE: Переключатель режима карты -->
    <div class="map-mode-control">
      <label for="mapModeSelect">Режим карты</label>
      <select id="mapModeSelect">
        <option value="yandex#map">Стандарт</option>
        <option value="yandex#satellite">Спутник</option>
        <option value="yandex#hybrid">Гибрид</option>
      </select>
    </div>
  </aside>

  <div class="sheet" id="bottomSheet">
    <form id="routeForm">
      <div class="field">
        <label for="fromInput">Откуда</label>
        <input id="fromInput" type="text" placeholder="Адрес или широта,долгота" autocomplete="off" />
      </div>
      <div class="field">
        <label for="toInput">Куда</label>
        <input id="toInput" type="text" placeholder="Адрес или широта,долгота" autocomplete="off" />
      </div>
      <div class="toggles">
        <label><input type="checkbox" id="weightToggle" checked /> Весовые рамки</label>
        <label><input type="checkbox" id="platonToggle" /> Платон</label>
        <label><input type="checkbox" id="tollToggle" /> Избегать платных дорог</label>
        <label><input type="checkbox" id="simplifyToggle" checked /> Упрощённые шаги</label>
      </div>
      <div class="actions">
        <button type="submit" id="buildRouteBtn">Построить маршрут</button>
        <button type="button" class="secondary" id="detourBtn">ИИ-объезд</button>
        <button type="button" class="danger" id="clearBtn">Очистить</button>
        <!-- // CHANGE: Упрощённый набор действий без GPX и геолокации -->
        <button type="button" class="secondary" id="shareBtn">Поделиться</button>
      </div>
    </form>
    <div class="steps" id="stepsBlock" hidden>
      <h3>Пошаговая навигация</h3>
      <ol id="stepsList"></ol>
    </div>
  </div>

  <script>
  (() => {
    const state = {
      map: null,
      routeLine: null,
      detourLine: null,
      routeMarkers: [],
      routeData: null,
      routeHistory: [],
      weightZones: [],
      platonZones: [],
      detourList: [],
      voiceQueue: [],
      speaking: false,
      currentStepIndex: 0,
      recommendations: [],
      activeRouteKind: 'main',
      mapMode: 'yandex#hybrid', // CHANGE: Текущий режим карты по умолчанию
    };

    const zoneCache = new Map();

    const elements = {
      fromInput: document.getElementById('fromInput'),
      toInput: document.getElementById('toInput'),
      weightToggle: document.getElementById('weightToggle'),
      platonToggle: document.getElementById('platonToggle'),
      tollToggle: document.getElementById('tollToggle'),
      form: document.getElementById('routeForm'),
      detourBtn: document.getElementById('detourBtn'),
      clearBtn: document.getElementById('clearBtn'),
      shareBtn: document.getElementById('shareBtn'),
      stepsBlock: document.getElementById('stepsBlock'),
      stepsList: document.getElementById('stepsList'),
      simplifyToggle: document.getElementById('simplifyToggle'),
      recommendations: document.getElementById('recommendations'),
      recommendationsList: document.getElementById('recommendationsList'),
      legend: document.getElementById('legend'),
      sheet: document.getElementById('bottomSheet'),
      legendToggleBtn: document.getElementById('legendToggleBtn'),
      recommendationsToggleBtn: document.getElementById('recommendationsToggleBtn'),
      sheetToggleBtn: document.getElementById('sheetToggleBtn'),
      loading: document.getElementById('loading'),
      mapModeSelect: document.getElementById('mapModeSelect'), // CHANGE: Селектор режима карты
    };

    let tollWarned = false;
    let loadingCounter = 0;

    if (elements.loading) {
      elements.loading.hidden = true;
      elements.loading.style.display = 'none';
    }

    function showLoading() {
      loadingCounter += 1;
      if (elements.loading) {
        elements.loading.hidden = false;
        elements.loading.style.display = 'flex';
      }
    }
    function hideLoading() {
      loadingCounter = Math.max(0, loadingCounter - 1);
      if (loadingCounter === 0 && elements.loading) {
        elements.loading.style.display = 'none';
        elements.loading.hidden = true;
      }
    }

    function applyMapMode(mode) { // CHANGE: Управление режимом отображения карты
      const type = typeof mode === 'string' ? mode : 'yandex#hybrid';
      state.mapMode = type;
      if (elements.mapModeSelect && elements.mapModeSelect.value !== type) {
        elements.mapModeSelect.value = type;
      }
      if (state.map && typeof state.map.setType === 'function') {
        state.map.setType(type);
      }
    }

    // -------- Suggest: безопасный фолбэк без устаревшего SuggestView
    function wireSuggestSafe(inputEl) {
      // Enter запускает построение маршрута
      inputEl.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          document.getElementById('buildRouteBtn')?.click();
        }
      });
      // Мягкий вызов ymaps.suggest (если есть), без UI, с глушением ошибок
      let timer = null;
      inputEl.addEventListener('input', () => {
        clearTimeout(timer);
        const query = inputEl.value.trim();
        if (query.length < 3) return;
        timer = setTimeout(async () => {
          try {
            if (typeof ymaps === 'object' && typeof ymaps.suggest === 'function') {
              await ymaps.suggest(query);
            }
          } catch (_) { /* ignore */ }
        }, 250);
      });
    }

    // -------- UI helpers
    function togglePanel(panel, button, label) {
      panel.classList.toggle('hidden');
      const hidden = panel.classList.contains('hidden');
      if (button) button.textContent = hidden ? `Показать ${label}` : `Скрыть ${label}`;
    }

    function setupResponsivePanels() {
      const mq = window.matchMedia('(max-width: 540px)');
      const apply = (event) => {
        const shouldCollapse = event.matches;
        const targets = [
          { panel: elements.legend, button: elements.legendToggleBtn, label: 'легенду' },
          { panel: elements.recommendations, button: elements.recommendationsToggleBtn, label: 'рекомендации' },
          { panel: elements.sheet, button: elements.sheetToggleBtn, label: 'панель' },
        ];
        targets.forEach(({ panel, button, label }) => {
          if (!panel) return;
          if (shouldCollapse) panel.classList.add('hidden');
          else panel.classList.remove('hidden');
          const hidden = panel.classList.contains('hidden');
          if (button) button.textContent = hidden ? `Показать ${label}` : `Скрыть ${label}`;
        });
      };
      apply(mq);
      const handler = (event) => apply(event);
      if (typeof mq.addEventListener === 'function') mq.addEventListener('change', handler);
      else if (typeof mq.addListener === 'function') mq.addListener(handler);
    }

    // -------- Map init
    initMap();

    async function initMap() {
      await new Promise((resolve) => ymaps.ready(resolve));
      restoreUI(); // CHANGE: Восстанавливаем настройки до инициализации карты
      const initialMode = state.mapMode || 'yandex#hybrid';
      state.map = new ymaps.Map(
        'map',
        { center: [55.751574, 37.573856], zoom: 6, controls: ['zoomControl'], type: initialMode },
        { suppressMapOpenBlock: true }
      );
      applyMapMode(initialMode); // CHANGE: Применяем сохранённый режим карты

      // вместо SuggestView — безопасный фолбэк
      wireSuggestSafe(elements.fromInput);
      wireSuggestSafe(elements.toInput);

      await loadZonesLazy();     // подгрузка зон (если есть файлы), не ломает работу без них
      bindEvents();
      applyZoneVisibility();
    }

    function bindEvents() {
      elements.form.addEventListener('submit', (event) => { event.preventDefault(); buildRoute(); });
      elements.detourBtn.addEventListener('click', handleDetour);
      elements.clearBtn.addEventListener('click', clearRoute);
      elements.shareBtn.addEventListener('click', shareRoute);
      elements.mapModeSelect?.addEventListener('change', () => {
        if (!state.map) return;
        const mode = elements.mapModeSelect.value;
        applyMapMode(mode);
        saveSettings();
      }); // CHANGE: Переключение режима карты

      elements.weightToggle.addEventListener('change', () => {
        saveSettings(); applyZoneVisibility();
        if (state.routeData) {
          state.routeData.intersections = detectIntersections(state.routeData.path);
          markRouteIntersections(state.routeData?.intersections || []);
          updateRecommendations();
        }
      });
      elements.platonToggle.addEventListener('change', () => {
        saveSettings(); applyZoneVisibility();
        if (state.routeData) {
          state.routeData.intersections = detectIntersections(state.routeData.path);
          markRouteIntersections(state.routeData?.intersections || []);
          updateRecommendations();
        }
      });
      elements.tollToggle.addEventListener('change', () => {
        saveSettings();
        if (elements.tollToggle.checked && !tollWarned) {
          alert('На публичном OSRM «избегать платных дорог» может игнорироваться. В ссылках Google/Яндекс режим учитывается.');
          tollWarned = true;
        }
        if (state.routeData) updateRecommendations();
      });
      elements.simplifyToggle?.addEventListener('change', () => {
        saveSettings();
        if (state.routeData) renderSteps(state.routeData.steps, elements.simplifyToggle.checked);
      });

      elements.fromInput.addEventListener('input', debounce(saveSettings, 400));
      elements.toInput.addEventListener('input', debounce(saveSettings, 400));

      elements.legendToggleBtn.addEventListener('click', () => togglePanel(elements.legend, elements.legendToggleBtn, 'легенду'));
      elements.recommendationsToggleBtn.addEventListener('click', () => togglePanel(elements.recommendations, elements.recommendationsToggleBtn, 'рекомендации'));
      elements.sheetToggleBtn.addEventListener('click', () => togglePanel(elements.sheet, elements.sheetToggleBtn, 'панель'));

      if (state.map) {
        state.map.events.add('boundschange', debounce(() => { redrawZonesInView(); }, 250));
      }
      setupResponsivePanels();
    }

   // -------- Zones (реальная подгрузка и отрисовка)
async function loadZonesLazy() {
  if (!state.map) return;
  const requests = [
    loadGeoJson('weigh_frames.geojson', {
      color: '#ff3b30',
      fillColor: 'rgba(255, 59, 48, 0.18)',
      defaultRadius: 500,
      target: state.weightZones,
      type: 'weight',
    }),
    loadGeoJson('platon.geojson', {
      color: '#ff9500',
      fillColor: 'rgba(255, 149, 0, 0.18)',
      defaultRadius: 300,
      target: state.platonZones,
      type: 'platon',
    }),
  ];
  await Promise.all(requests);
  redrawZonesInView();
}

async function loadGeoJson(url, options) {
  try {
    if (zoneCache.has(url)) {
      options.target.splice(0, options.target.length, ...cloneZones(zoneCache.get(url)));
      return;
    }
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    if (!Array.isArray(data.features)) return;

    const zones = data.features
      .filter(f => f.geometry && f.geometry.type === 'Point')
      .map(f => {
        const [lon, lat] = f.geometry.coordinates;
        const props = f.properties || {};
        const radius = Number(props.radius_m) || options.defaultRadius;
        return {
          type: options.type,
          center: [lat, lon],
          radius,
          color: options.color,
          fillColor: options.fillColor,
          properties: {
            name: props.name || 'Без названия',
            road: props.road || '',
            km: props.km || '',
            note: props.note || '',
          },
          placemark: null,
          circle: null,
          rendered: false,
          __selected: false,
          __intersects: true,
        };
      });
    zoneCache.set(url, zones);
    options.target.splice(0, options.target.length, ...cloneZones(zones));
  } catch (e) {
    console.warn('Ошибка загрузки GeoJSON', url, e);
  }
}

function cloneZones(zones) {
  return zones.map(z => ({
    ...z,
    properties: { ...z.properties },
    placemark: null,
    circle: null,
    rendered: false,
    __selected: Boolean(z.__selected),
    __intersects: z.__intersects !== false,
  }));
}

function buildBalloon(props) {
  const lines = [];
  lines.push(`<strong>${escapeHtml(props.name)}</strong>`);
  const roadParts = [];
  if (props.road) roadParts.push(escapeHtml(props.road));
  if (props.km) roadParts.push(`км ${escapeHtml(String(props.km))}`);
  if (roadParts.length) lines.push(roadParts.join(', '));
  if (props.note) lines.push(`Объезд: ${escapeHtml(props.note)}`);
  return lines.join('<br/>');
}

function redrawZonesInView() {
  if (!state.map) return;
  const bounds = state.map.getBounds();
  if (!bounds) return;
  const [[southLat, westLon], [northLat, eastLon]] = bounds;
  const minLat = Math.min(southLat, northLat);
  const maxLat = Math.max(southLat, northLat);
  const minLon = Math.min(westLon, eastLon);
  const maxLon = Math.max(westLon, eastLon);
  const inBounds = ([lat, lon]) => lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon;

  const showWeight = elements.weightToggle?.checked;
  const showPlaton = elements.platonToggle?.checked;
  const restrictByRoute = Boolean(state.routeData);

  const processZone = (zone, visible) => {
    const intersectsRoute = !restrictByRoute || zone.__intersects;
    const shouldRender = visible && intersectsRoute && inBounds(zone.center);

    if (shouldRender && !zone.rendered) {
      const balloon = buildBalloon(zone.properties);
      zone.placemark = new ymaps.Placemark(
        zone.center,
        { balloonContent: balloon, hintContent: zone.properties.name },
        { preset: 'islands#dotIcon', iconColor: zone.color }
      );
      zone.circle = new ymaps.Circle([zone.center, zone.radius], {}, {
        fillColor: zone.fillColor,
        strokeColor: zone.color,
        strokeWidth: zone.__selected ? 3 : 2,
        strokeOpacity: zone.__selected ? 0.9 : 0.6,
        fillOpacity: zone.__selected ? 0.45 : 0.35,
      });
      state.map.geoObjects.add(zone.circle);
      state.map.geoObjects.add(zone.placemark);

      const onToggle = () => {
        if (!state.routeData) { alert('Сначала постройте маршрут.'); return; }
        zone.__selected = !zone.__selected;
        if (zone.circle) {
          zone.circle.options.set('strokeWidth', zone.__selected ? 3 : 2);
          zone.circle.options.set('strokeOpacity', zone.__selected ? 0.9 : 0.6);
          zone.circle.options.set('fillOpacity', zone.__selected ? 0.45 : 0.35);
        }
        syncDetourList();
        updateRecommendations(); // CHANGE: моментально обновляем подсказки
      };
      zone.circle.events.add('click', onToggle);
      zone.placemark.events.add('click', onToggle);

      zone.rendered = true;
    } else if (shouldRender && zone.rendered) {
      // просто освежим стиль выбора
      if (zone.circle) {
        zone.circle.options.set('strokeWidth', zone.__selected ? 3 : 2);
        zone.circle.options.set('strokeOpacity', zone.__selected ? 0.9 : 0.6);
        zone.circle.options.set('fillOpacity', zone.__selected ? 0.45 : 0.35);
      }
    } else if (!shouldRender && zone.rendered) {
      if (zone.circle) state.map.geoObjects.remove(zone.circle);
      if (zone.placemark) state.map.geoObjects.remove(zone.placemark);
      zone.circle = null;
      zone.placemark = null;
      zone.rendered = false;
    }
  };

  state.weightZones.forEach(z => processZone(z, showWeight));
  state.platonZones.forEach(z => processZone(z, showPlaton));
}

function applyZoneVisibility() {
  redrawZonesInView();
  syncDetourList();
}

function syncDetourList() {
  const selected = [...state.weightZones, ...state.platonZones].filter(z => z && z.__selected);
  const uniq = [];
  const seen = new Set();
  selected.forEach(z => { if (!seen.has(z)) { seen.add(z); uniq.push(z); } });
  state.detourList = uniq;
  if (state.routeData) updateRecommendations(); // CHANGE: Поддерживаем подсказки по выбранным зонам
}

function markRouteIntersections(hits) {
  const zones = [...state.weightZones, ...state.platonZones];
  zones.forEach(z => { z.__intersects = false; });
  (hits || []).forEach(hit => { if (hit?.zone) hit.zone.__intersects = true; });
  redrawZonesInView();
  syncDetourList(); // CHANGE: Пересчитываем выбранные зоны после обновления пересечений
}

function clearZoneIntersectionFlags() {
  [...state.weightZones, ...state.platonZones].forEach(z => { z.__intersects = true; });
  redrawZonesInView();
}

function resetZoneSelections() {
  [...state.weightZones, ...state.platonZones].forEach(z => { z.__selected = false; });
  syncDetourList();
  state.detourList = [];
}

// Пересечения маршрута с кругами зон
function detectIntersections(path) { // CHANGE: Возвращаем ближайшие точки попадания в зону
  if (!Array.isArray(path) || path.length < 2) return [];
  const all = [...state.weightZones, ...state.platonZones];
  const out = [];
  all.forEach(zone => {
    if (!zone) return;
    for (let i = 0; i < path.length - 1; i += 1) {
      const p1 = path[i], p2 = path[i + 1];
      const info = pointToSegmentInfo(zone.center, p1, p2);
      if (info.distance <= (zone.radius || 0)) {
        out.push({ zone, point: info.point, closestPoint: info.point, segmentIndex: i, distance: info.distance });
        break;
      }
    }
  });
  return out;
}

// Приближённое расстояние от точки до отрезка в метрах (проекция на «плоскость» по средней широте)
function pointToSegmentInfo(p, a, b) { // CHANGE: Возвращаем проекцию и расстояние
  const R = 6371000;
  const lat0 = ((a[0] + b[0]) / 2) * Math.PI / 180;
  const toXY = ([lat, lon]) => {
    const x = R * (lon * Math.PI / 180) * Math.cos(lat0);
    const y = R * (lat * Math.PI / 180);
    return { x, y };
  };
  const A = toXY(a), B = toXY(b), P = toXY(p);
  const vx = B.x - A.x, vy = B.y - A.y;
  const wx = P.x - A.x, wy = P.y - A.y;
  const c1 = vx * wx + vy * wy;
  const c2 = vx * vx + vy * vy;
  const t = c2 === 0 ? 0 : Math.max(0, Math.min(1, c1 / c2));
  const proj = { x: A.x + t * vx, y: A.y + t * vy };
  const distance = Math.hypot(P.x - proj.x, P.y - proj.y);
  const toLatLon = ({ x, y }) => {
    const lat = y / R;
    const lon = x / (R * Math.cos(lat0));
    return [lat * 180 / Math.PI, lon * 180 / Math.PI];
  };
  const projectedPoint = toLatLon(proj);
  return { distance, point: projectedPoint };
}
function pointToSegmentMeters(p, a, b) { return pointToSegmentInfo(p, a, b).distance; }

function findNearestPointOnPath(point, path) { // CHANGE: Ищем ближайший сегмент маршрута
  if (!Array.isArray(point) || !Array.isArray(path) || path.length < 2) return null;
  let best = null;
  for (let i = 0; i < path.length - 1; i += 1) {
    const info = pointToSegmentInfo(point, path[i], path[i + 1]);
    if (!info) continue;
    if (!best || info.distance < best.distance) {
      best = { point: info.point, closestPoint: info.point, segmentIndex: i, distance: info.distance };
    }
  }
  return best;
}
// ---------- Address/coords resolving ----------
async function resolveInput(value) {
  // 1) Уже координаты массивом?
  if (Array.isArray(value) && value.length === 2) {
    const lat = Number(value[0]);
    const lon = Number(value[1]);
    if (Number.isFinite(lat) && Number.isFinite(lon)) return [lat, lon];
  }
  // 2) Объект вида {lat,lon} / {latitude,longitude}
  if (value && typeof value === 'object' && !Array.isArray(value)) {
    if (Number.isFinite(value.lat) && Number.isFinite(value.lon)) {
      return [Number(value.lat), Number(value.lon)];
    }
    if (Number.isFinite(value.latitude) && Number.isFinite(value.longitude)) {
      return [Number(value.latitude), Number(value.longitude)];
    }
  }
  // 3) Строка: "lat,lon" или адрес
  if (typeof value === 'string') {
    const trimmed = value.trim();
    if (!trimmed) return null;

    // 3.1 Координаты "lat,lon" или "lat;lon"
    const parsed = parseLatLon(trimmed);
    if (parsed) return parsed;

    // 3.2 Геокод адреса через Яндекс
    try {
      if (typeof ymaps?.geocode === 'function') {
        const result = await ymaps.geocode(trimmed, { results: 1 });
        if (result.geoObjects.getLength()) {
          const coords = result.geoObjects.get(0).geometry.getCoordinates(); // [lat, lon]
          if (Array.isArray(coords) && coords.length === 2) return coords;
        }
      }
    } catch (e) {
      console.warn('Ошибка геокодирования:', e);
    }
  }
  return null;
}

function parseLatLon(str) {
  // Разделители: запятая или ';' (пробелы игнорируем)
  const clean = String(str).trim().replace(/\s+/g, '');
  const parts = clean.split(/[;,]/);
  if (parts.length !== 2) return null;
  const lat = Number(parts[0]);
  const lon = Number(parts[1]);
  if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
  if (Math.abs(lat) > 90 || Math.abs(lon) > 180) return null;
  return [lat, lon];
}

    // -------- Routing
    async function buildRoute(options = {}) {
      showLoading();
      try {
        const fromValue = options.from ?? elements.fromInput.value.trim();
        const toValue = options.to ?? elements.toInput.value.trim();
        if (!fromValue || !toValue) { alert('Укажите точки начала и конца маршрута.'); return; }

        const from = await resolveInput(fromValue);
        const to = await resolveInput(toValue);
        if (!from || !to) { alert('Не удалось определить координаты. Проверьте введённые данные.'); return; }

        const viaRaw = Array.isArray(options.via) ? options.via : [];
        const viaResolved = [];
        for (const v of viaRaw) {
          const p = await resolveInput(v);
          if (p) viaResolved.push(p);
        }

        const coordsList = [from, ...viaResolved, to];
        const avoidToll = Boolean(elements.tollToggle.checked);
        const routeData = await requestRouteWithRetry(coordsList, avoidToll, 2);
        if (!routeData) {
          alert('Маршрут не найден. Попробуйте изменить точки.');
          offerRouteFallback(from, to, new Error('OSRM вернул пустой маршрут'));
          return;
        }

        if (state.routeData) state.routeHistory.push(state.routeData);

        state.routeData = {
          coordsList,
          path: routeData.path,
          distance: routeData.distance,
          duration: routeData.duration,
          steps: routeData.steps,
          intersections: detectIntersections(routeData.path),
        };
        markRouteIntersections(state.routeData?.intersections || []);

        state.activeRouteKind = options.detour ? 'detour' : 'main';
        clearDetour();
        if (!options.detour) {
          resetZoneSelections(); // CHANGE: Основной маршрут очищает выбор зон
        }

        renderRoute(routeData.path, coordsList);
        if (options.detour) drawDetour(routeData.path);

        renderSteps(routeData.steps, elements.simplifyToggle?.checked);
        speakSteps(routeData.steps);
        updateRecommendations();
        if (!options.detour) {
          state.detourList = []; // CHANGE: Для основного маршрута сбрасываем выбранные зоны
        }

        return state.routeData;
      } catch (error) {
        console.warn(error);
        alert(error && error.message ? error.message : 'Не удалось построить маршрут. Попробуйте ещё раз.');
      } finally {
        hideLoading();
      }
    }

    async function requestRouteWithRetry(coordsList, avoidToll, attempts = 2) {
      let lastError = null;
      for (let i = 0; i < attempts; i += 1) {
        try { return await requestRoute(coordsList, avoidToll); }
        catch (e) { lastError = e; if (i < attempts - 1) await delay(700); }
      }
      throw lastError || new Error('Не удалось получить маршрут.');
    }

    async function requestRoute(coordsList, avoidToll) {
      const points = coordsList.map((c) => `${c[1]},${c[0]}`).join(';');
      const url = new URL(`https://router.project-osrm.org/route/v1/driving/${points}`);
      url.searchParams.set('overview', 'full');
      url.searchParams.set('geometries', 'geojson');
      url.searchParams.set('steps', 'true');
      if (avoidToll) url.searchParams.set('exclude', 'toll');

      const response = await fetch(url.toString());
      if (!response.ok) throw new Error('Сервис маршрутов временно недоступен.');
      const data = await response.json();
      if (!data.routes || !data.routes.length) return null;

      const route = data.routes[0];
      const path = route.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
      const steps = [];
      route.legs.forEach((leg) => {
        leg.steps.forEach((step) => {
          steps.push({
            text: step.maneuver.instruction || formatStep(step),
            distance: step.distance,
            duration: step.duration,
            name: step.name || '',
            maneuver: step.maneuver || null,
          });
        });
      });
      return { path, steps, distance: route.distance, duration: route.duration };
    }

    async function handleDetour() {
      showLoading();
      try {
        if (!state.routeData) { alert('Сначала постройте маршрут.'); return; }
        const baseRoute = state.routeData;
        const intersections = Array.isArray(baseRoute.intersections) ? baseRoute.intersections : [];
        const selectedZones = (state.detourList || []).filter(Boolean);
        const zonesSource = selectedZones.length ? selectedZones : intersections.map((hit) => hit.zone).filter(Boolean);
        // CHANGE: Предпочитаем вручную выбранные зоны, иначе используем зоны пересечений
        if (!zonesSource.length) { alert('Зоны на маршруте не обнаружены.'); return; }

        const uniqueZones = [];
        const seenZones = new Set();
        zonesSource.forEach((zone) => {
          if (zone && !seenZones.has(zone)) {
            seenZones.add(zone);
            uniqueZones.push(zone);
          }
        });

        const candidates = [];
        uniqueZones.forEach((zone) => {
          // CHANGE: Для каждой зоны строим обходную точку за пределами радиуса
          const hit = intersections.find((item) => item.zone === zone);
          const anchor = hit || findNearestPointOnPath(zone.center, baseRoute.path);
          if (!anchor || !Number.isFinite(anchor.segmentIndex)) return;
          const segmentStart = baseRoute.path[anchor.segmentIndex];
          const segmentEnd = baseRoute.path[anchor.segmentIndex + 1] || segmentStart;
          const basePoint = anchor.closestPoint || anchor.point || zone.center;
          const offsetDistance = Math.max((zone.radius || 400) * 1.3, 300);
          const detourPoint = buildDetourPoint(basePoint, segmentStart, segmentEnd, zone.center, offsetDistance, zone.radius || 0);
          if (!detourPoint) return;
          const minGap = Math.max(300, (zone.radius || 0) * 0.7);
          candidates.push({ point: detourPoint, segmentIndex: anchor.segmentIndex, zone, minGap });
        });

        const filtered = filterDetourCandidates(candidates); // CHANGE: Уплотняем список via-точек
        const via = selectEvenly(filtered.map((item) => item.point), Math.min(6, filtered.length));

        if (!via.length) { alert('Не удалось вычислить точки объезда.'); return; }

        const start = baseRoute.coordsList[0];
        const finish = baseRoute.coordsList[baseRoute.coordsList.length - 1];

        await buildRoute({ from: start, to: finish, via, detour: true });
      } catch (e) {
        console.warn('Ошибка построения объезда', e);
        alert('Не удалось построить альтернативный маршрут. Попробуйте позже.');
        clearDetour();
        state.activeRouteKind = 'main';
      } finally {
        hideLoading();
      }
    }

    function renderRoute(path, coordsList) {
      if (!state.map || !Array.isArray(path) || !path.length) return;

      if (state.routeLine) state.map.geoObjects.remove(state.routeLine);
      state.routeMarkers.forEach((m) => state.map.geoObjects.remove(m));
      state.routeMarkers = [];

      state.routeLine = new ymaps.Polyline(path, {}, { strokeColor: '#1b6cff', strokeWidth: 6, strokeOpacity: 0.95 });
      state.map.geoObjects.add(state.routeLine);

      coordsList.forEach((coord, idx) => {
        const caption = idx === 0 ? 'Старт' : (idx === coordsList.length - 1 ? 'Финиш' : `Точка ${idx}`);
        const marker = new ymaps.Placemark(coord, { iconCaption: caption }, { preset: 'islands#blueCircleIcon' });
        state.routeMarkers.push(marker);
        state.map.geoObjects.add(marker);
      });

      const bounds = state.routeLine.geometry.getBounds();
      if (bounds) state.map.setBounds(bounds, { checkZoomRange: true, zoomMargin: [40, 240, 240, 40] });
    }

    function buildDetourPoint(basePoint, segmentStart, segmentEnd, zoneCenter, distance, zoneRadius) { // CHANGE: Расчёт точки объезда по нормали
      if (!Array.isArray(basePoint) || basePoint.length !== 2) return null;
      let alongBearing = bearingBetween(segmentStart || basePoint, segmentEnd || basePoint);
      if (!Number.isFinite(alongBearing) || haversine(segmentStart || basePoint, segmentEnd || basePoint) < 1) {
        alongBearing = bearingBetween(zoneCenter, basePoint);
      }
      if (!Number.isFinite(alongBearing)) return null;
      const leftBearing = alongBearing + Math.PI / 2;
      const rightBearing = alongBearing - Math.PI / 2;
      const leftPoint = destinationPoint(basePoint, leftBearing, distance);
      const rightPoint = destinationPoint(basePoint, rightBearing, distance);
      const leftDistance = haversine(leftPoint, zoneCenter);
      const rightDistance = haversine(rightPoint, zoneCenter);
      let candidate = leftDistance > rightDistance ? leftPoint : rightPoint;
      if (zoneCenter && haversine(candidate, zoneCenter) < Math.max(zoneRadius * 1.05, distance * 0.75)) {
        const escapeBearing = bearingBetween(zoneCenter, basePoint);
        if (Number.isFinite(escapeBearing)) {
          candidate = destinationPoint(zoneCenter, escapeBearing, Math.max(distance + zoneRadius, zoneRadius * 1.6 || distance));
        }
      }
      return candidate;
    }

    function filterDetourCandidates(candidates) { // CHANGE: Отсекаем точки, которые слишком близко друг к другу
      if (!Array.isArray(candidates)) return [];
      const sorted = [...candidates].sort((a, b) => (a.segmentIndex || 0) - (b.segmentIndex || 0));
      const result = [];
      sorted.forEach((candidate) => {
        if (!candidate?.point) return;
        const threshold = Math.max(250, candidate.minGap || 0);
        const isClose = result.some((existing) => haversine(existing.point, candidate.point) < Math.min(existing.threshold, threshold));
        if (!isClose) {
          result.push({ point: candidate.point, segmentIndex: candidate.segmentIndex, threshold });
        }
      });
      return result;
    }

    function drawDetour(coords) {
      clearDetour();
      if (!state.map || !Array.isArray(coords) || !coords.length) return;
      state.detourLine = new ymaps.Polyline(coords, {}, { strokeColor: '#9e9e9e', strokeWidth: 5, strokeOpacity: 0.75, strokeStyle: 'shortdash' });
      state.map.geoObjects.add(state.detourLine);
    }
    function clearDetour() {
      if (state.detourLine && state.map) state.map.geoObjects.remove(state.detourLine);
      state.detourLine = null;
    }

    function renderSteps(steps, simplify = false) {
      const list = elements.stepsList;
      list.innerHTML = '';
      state.currentStepIndex = 0;

      if (!Array.isArray(steps) || !steps.length) { elements.stepsBlock.hidden = true; return; }

      // локализация + фильтр шума
      const prepared = steps.map((step, idx) => {
        const ref = step || {};
        const localized = getLocalizedInstruction(ref);
        ref.localizedText = localized || (ref.text || '').trim();
        const type = (ref.maneuver?.type || ref.type || '').toLowerCase();
        return {
          originalIndex: idx,
          type,
          distance: Number(ref.distance) || 0,
          duration: Number(ref.duration) || 0,
          displayText: ref.localizedText || 'Двигайтесь прямо',
        };
      });

      const noiseTypes = new Set(['depart', 'arrive', 'new name', 'end of road']);
      const filtered = prepared.filter((item) => {
        if (noiseTypes.has(item.type)) return false;
        if (simplify && item.distance < 120) return false;
        return Boolean(item.displayText);
      });

      // Схлопываем одинаковые подряд
      const merged = [];
      filtered.forEach((item) => {
        const last = merged[merged.length - 1];
        if (last && last.displayText === item.displayText) {
          last.distance += item.distance;
          last.duration += item.duration;
          last.indices.push(item.originalIndex);
        } else {
          merged.push({ displayText: item.displayText, distance: item.distance, duration: item.duration, indices: [item.originalIndex] });
        }
      });

      if (!merged.length) { elements.stepsBlock.hidden = true; return; }

      // Объединяем короткие участки < 500м стрелочкой →
      let finalSteps = merged;
      if (simplify) {
        const aggregated = [];
        let buffer = null;
        const flush = () => { if (buffer) { aggregated.push(buffer); buffer = null; } };
        merged.forEach((item) => {
          const clone = { displayText: item.displayText, distance: item.distance, duration: item.duration, indices: [...item.indices] };
          if (clone.distance < 500) {
            if (!buffer) buffer = { ...clone };
            else {
              buffer.displayText = `${buffer.displayText} → ${clone.displayText}`;
              buffer.distance += clone.distance;
              buffer.duration += clone.duration;
              buffer.indices.push(...clone.indices);
            }
          } else {
            flush(); aggregated.push(clone);
          }
        });
        flush();
        finalSteps = aggregated;
      }

      finalSteps.forEach((item, idx) => {
        const li = document.createElement('li');
        li.textContent = `${item.displayText} (${formatDistance(item.distance)}, ${formatDuration(item.duration)})`;
        const indices = item.indices && item.indices.length ? item.indices : [idx];
        li.dataset.originalIndex = String(indices[0]);
        li.dataset.originalIndices = indices.join(',');
        li.dataset.listIndex = String(idx);
        list.appendChild(li);
      });

      elements.stepsBlock.hidden = false;
      list.firstElementChild?.classList.add('active');
    }

    function getLocalizedInstruction(step) {
      if (!step) return '';
      const rawText = (step.text || '').trim();
      const m = step.maneuver || {};
      const type = (m.type || step.type || '').toLowerCase();
      const modifier = (m.modifier || step.modifier || '').toLowerCase();
      const name = (step.name || '').trim();
      const exit = m.exit;
      const on = name ? ` на ${name}` : '';
      const along = name ? ` по ${name}` : '';

      const dir = (mod) => ({
        left: 'налево', right: 'направо',
        sharp_left: 'резко налево', sharp_right: 'резко направо',
        slight_left: 'плавно налево', slight_right: 'плавно направо',
        straight: 'прямо', uturn: 'на разворот'
      }[mod] || '');

      const lane = (mod) => ({
        left: 'левее', right: 'правее',
        slight_left: 'плавно левее', slight_right: 'плавно правее',
        sharp_left: 'резко левее', sharp_right: 'резко правее',
        straight: 'прямо'
      }[mod] || '');

      switch (type) {
        case 'turn':
          if (modifier === 'uturn') return `Развернитесь${on}`;
          return dir(modifier) ? `Поверните ${dir(modifier)}${on}` : `Поверните${on}`;
        case 'fork':
          return lane(modifier) ? `Держитесь ${lane(modifier)}${along}` : `Держитесь${along}`;
        case 'merge':
          return lane(modifier) ? `Перестройтесь ${lane(modifier)}${along}` : `Перестройтесь${along}`;
        case 'off ramp':
        case 'on ramp':
        case 'ramp':
        case 'exit':
          if (modifier === 'uturn') return `Развернитесь${on}`;
          return dir(modifier) ? `Съезд ${dir(modifier)}${on}` : `Съезд${on}`;
        case 'roundabout':
        case 'roundabout turn':
        case 'rotary':
          return `На кольцевой развязке используйте ${exit ? `${exit}-й съезд` : 'нужный съезд'}${on}`;
        case 'continue':
          if (modifier === 'uturn') return `Развернитесь${on}`;
          if (modifier === 'straight' || !modifier) return `Продолжайте движение${along}`;
          if (lane(modifier)) return `Продолжайте движение, держитесь ${lane(modifier)}${along}`;
          return dir(modifier) ? `Продолжайте движение ${dir(modifier)}${along}` : `Продолжайте движение${along}`;
        default: break;
      }
      if (rawText) return rawText;
      return name ? `Двигайтесь по ${name}` : '';
    }
// Голосовые подсказки + подсветка активного шага
function setActiveStep(index) {
  state.currentStepIndex = index;
  const items = elements.stepsList.querySelectorAll('li');
  items.forEach((el) => el.classList.remove('active'));

  // пробуем найти по исходному индексу ОСRM или по индексу в списке
  const byOriginal = elements.stepsList.querySelector(`li[data-original-index="${index}"]`);
  const byList = elements.stepsList.querySelector(`li[data-list-index="${index}"]`);
  const target = byOriginal || byList || items[index] || null;
  if (target) target.classList.add('active');
}

function speakSteps(steps) {
  if (!Array.isArray(steps) || !steps.length) return;
  if (!('speechSynthesis' in window)) return;

  window.speechSynthesis.cancel();

  // подготовим текст (используем локализованные инструкции, если есть)
  state.voiceQueue = steps.map((s) => {
    const txt = getLocalizedInstruction(s) || s.text || '';
    return { ...s, localizedText: txt };
  });

  state.speaking = false;
  state.currentStepIndex = 0;
  speakNext();
}

function speakNext() {
  if (!state.voiceQueue.length) { state.speaking = false; return; }

  const step = state.voiceQueue.shift();
  const utter = new SpeechSynthesisUtterance(step.localizedText || step.text || '');
  utter.lang = 'ru-RU';
  utter.rate = 1;

  // Подсветим соответствующий шаг в списке (если нашли его в оригинальном массиве)
  const idx = (state.routeData?.steps || []).indexOf(step);
  if (idx >= 0) setActiveStep(idx);

  utter.onend = () => {
    // Пауза между репликами ~ длительность шага (саницезировано)
    const ms = Math.min(Math.max((Number(step.duration) || 0) * 1000, 2000), 8000);
    setTimeout(speakNext, ms);
  };

  state.speaking = true;
  window.speechSynthesis.speak(utter);
}

    // -------- Share (Google / Яндекс / Навигатор / WhatsApp)
    function formatPointIfNeeded(p) {
      if (Array.isArray(p) && p.length === 2) return `${Number(p[0]).toFixed(6)},${Number(p[1]).toFixed(6)}`;
      return String(p || '');
    }

    function shareRoute() {
      if (!state.routeData || !state.routeData.path || state.routeData.path.length < 2) {
        alert('Постройте маршрут, чтобы поделиться.');
        return;
      }
      const payload = buildSharePayload(state.routeData);
      if (!payload) { alert('Недостаточно данных маршрута для шаринга.'); return; }

      const answer = window.prompt(
        'Куда отправить?\n1 — WhatsApp\n2 — Скопировать ссылки\n3 — Открыть в Навигаторе (с via)\n4 — Открыть в Навигаторе (A→B)\nОтмена — открыть Google Maps.',
        '1'
      ); // CHANGE: Добавлена опция Навигатора с via-точками
      if (answer === null) {
        window.open(payload.googleUrl, '_blank');
        return;
      }
      switch (answer.trim()) {
        case '1': window.open(payload.whatsApp, '_blank'); break;
        case '2':
          if (navigator.clipboard?.writeText) {
            navigator.clipboard.writeText(payload.shareText)
              .then(() => alert('Ссылки скопированы в буфер обмена.'))
              .catch(() => window.prompt('Скопируйте вручную:', payload.shareText));
          } else window.prompt('Скопируйте вручную:', payload.shareText);
          break;
        case '3':
          if (payload.navigatorViaUrl) window.location.href = payload.navigatorViaUrl;
          else window.location.href = payload.navigatorFallbackUrl;
          break;
        case '4':
          window.location.href = payload.navigatorFallbackUrl;
          break;
        default: window.open(payload.googleUrl, '_blank');
      }
    }

    function buildSharePayload(route) {
      if (!route || !Array.isArray(route.path) || route.path.length < 2) return null;

      const maxPts = 8;
      const pts = typeof pickEvenlySpacedPoints === 'function'
        ? pickEvenlySpacedPoints(route.path, Math.min(maxPts, Math.max(2, Math.ceil(route.path.length / 50))))
        : (route.path.length > 2
            ? [route.path[0], route.path[Math.floor(route.path.length/2)], route.path[route.path.length-1]]
            : [route.path[0], route.path[route.path.length-1]]);

      const origin = pts[0];
      const destination = pts[pts.length - 1];
      const via = pts.slice(1, -1);
      const fmt = (p) => formatPointIfNeeded(p);

      const g = new URL('https://www.google.com/maps/dir/');
      g.searchParams.set('api', '1');
      g.searchParams.set('origin', fmt(origin));
      g.searchParams.set('destination', fmt(destination));
      if (via.length) g.searchParams.set('waypoints', via.map(fmt).join('|'));
      g.searchParams.set('travelmode', 'driving');
      if (elements.tollToggle?.checked) g.searchParams.set('avoid', 'tolls');
      const googleUrl = g.toString();

      const yPoints = [origin, ...via, destination].map(fmt).join('~');
      const yandexUrl = `https://yandex.ru/maps/?rtext=${yPoints}&rtt=auto`;

      const navParams = new URLSearchParams({
        lat_from: origin[0].toFixed(6),
        lon_from: origin[1].toFixed(6),
        lat_to: destination[0].toFixed(6),
        lon_to: destination[1].toFixed(6),
      });
      const navigatorFallbackUrl = `yandexnavi://build_route_on_map?${navParams.toString()}`;
      let navigatorViaUrl = '';
      if (via.length) {
        const viaParam = via
          .map((point) => `${Number(point[0]).toFixed(6)},${Number(point[1]).toFixed(6)}`)
          .join(';');
        const viaParams = new URLSearchParams(navParams);
        viaParams.set('via', viaParam); // CHANGE: Яндекс.Навигатор принимает via=lat,lon;lat,lon
        navigatorViaUrl = `yandexnavi://build_route_on_map?${viaParams.toString()}`;
      }

      const routeLabel = state.activeRouteKind === 'detour' ? 'объездной маршрут' : 'основной маршрут';
      const rec = Array.isArray(state.recommendations) && state.recommendations.length ? `\n${state.recommendations.join('\n')}` : '';
      const navLines = navigatorViaUrl
        ? [`Яндекс.Навигатор (via): ${navigatorViaUrl}`, `Яндекс.Навигатор (A→B): ${navigatorFallbackUrl}`]
        : [`Яндекс.Навигатор: ${navigatorFallbackUrl}`];
      const viaText = via.length ? `\nVia-точки: ${via.map(fmt).join(' → ')}` : ''; // CHANGE: Добавляем via в текст шаринга
      const shareText = `${routeLabel}:\nGoogle Maps: ${googleUrl}\nЯндекс.Карты: ${yandexUrl}\n${navLines.join('\n')}${viaText}${rec}`;
      const whatsApp = `https://wa.me/?text=${encodeURIComponent(shareText)}`;

      return { googleUrl, yandexUrl, navigatorViaUrl, navigatorFallbackUrl, shareText, whatsApp };
    }

    function buildDirectLinks(from, to) {
      if (!Array.isArray(from) || !Array.isArray(to)) return [];
      const fmt = (p) => formatPointIfNeeded(p);

      const g = new URL('https://www.google.com/maps/dir/');
      g.searchParams.set('api', '1');
      g.searchParams.set('origin', fmt(from));
      g.searchParams.set('destination', fmt(to));
      g.searchParams.set('travelmode', 'driving');
      if (elements.tollToggle?.checked) g.searchParams.set('avoid', 'tolls');

      const y = `https://yandex.ru/maps/?rtext=${fmt(from)}~${fmt(to)}&rtt=auto`;
      const nav = `yandexnavi://build_route_on_map?lat_from=${from[0].toFixed(6)}&lon_from=${from[1].toFixed(6)}&lat_to=${to[0].toFixed(6)}&lon_to=${to[1].toFixed(6)}`;

      return [`Google Maps: ${g.toString()}`, `Яндекс.Карты: ${y}`, `Яндекс.Навигатор: ${nav}`];
    }

    // -------- Fallback / Recs / Settings // CHANGE: Убраны GPX и геолокация
    function offerRouteFallback(from, to, error) {
      let message = 'Не удалось получить маршрут от сервера OSRM.';
      if (error?.message) message += `\nПричина: ${error.message}`;
      const links = buildDirectLinks(from, to);
      if (links.length) message += `\n\nПопробуйте открыть маршрут вручную:\n${links.join('\n')}`;
      alert(message);
    }

    function clearRoute() {
      if (state.routeLine) { state.map.geoObjects.remove(state.routeLine); state.routeLine = null; }
      resetZoneSelections();
      clearDetour();
      clearZoneIntersectionFlags();
      state.activeRouteKind = 'main';
      state.routeMarkers.forEach((m) => state.map.geoObjects.remove(m));
      state.routeMarkers = [];
      state.routeData = null;
      state.detourList = [];
      elements.stepsBlock.hidden = true;
      elements.stepsList.innerHTML = '';
      if (window.speechSynthesis?.cancel) window.speechSynthesis.cancel();
      state.voiceQueue = [];
      state.recommendations = [];
      updateRecommendations(true);
    }

    function updateRecommendations(reset = false) {
      if (reset || !state.routeData) {
        state.recommendations = ['Постройте маршрут, чтобы получить рекомендации.'];
        renderRecommendations();
        return;
      }
      const ints = Array.isArray(state.routeData.intersections) ? state.routeData.intersections : [];
      const weightCount = ints.filter((h) => h.zone?.type === 'weight').length;
      const platonCount = ints.filter((h) => h.zone?.type === 'platon').length;

      const msgs = [];
      if (ints.length) {
        const parts = [];
        if (weightCount) parts.push(`весовые: ${weightCount}`);
        if (platonCount) parts.push(`Платон: ${platonCount}`);
        msgs.push(`На маршруте ${ints.length} зон (${parts.join(', ')}).`);
      } else {
        msgs.push('Опасных зон на маршруте не обнаружено.');
      }
      msgs.push(`Протяжённость: ${formatDistance(state.routeData.distance)}, время: ${formatDuration(state.routeData.duration)}.`);
      if (elements.tollToggle.checked) msgs.push('Включено «избегать платных дорог» (на demo-OSRM может игнорироваться).');

      const prev = [...state.routeHistory].reverse().find(Boolean);
      if (prev?.distance && prev?.duration) {
        const dd = state.routeData.distance - prev.distance;
        const dt = state.routeData.duration - prev.duration;
        if (Math.abs(dd) > 500) msgs.push(`Длина ${dd > 0 ? 'увеличилась' : 'уменьшилась'} на ${formatDistance(Math.abs(dd))}.`);
        if (Math.abs(dt) > 120) msgs.push(`Время ${dt > 0 ? 'увеличилось' : 'уменьшилось'} на ${formatDuration(Math.abs(dt))}.`);
      }
      if (state.detourList && state.detourList.length) {
        const names = state.detourList.map((zone) => zone?.properties?.name).filter(Boolean);
        if (names.length) msgs.push(`Выбрано зон для объезда: ${names.join(', ')}.`);
        else msgs.push(`Выбрано зон для объезда: ${state.detourList.length}.`);
        const notes = new Set();
        state.detourList.forEach((zone) => {
          const note = (zone?.properties?.note || '').trim();
          if (note) notes.add(note);
        });
        notes.forEach((note) => msgs.push(`Подсказка: ${note}`)); // CHANGE: Показываем подсказки из выбранных зон
      }
      state.recommendations = msgs;
      renderRecommendations();
    }

    function renderRecommendations() {
      const items = Array.isArray(state.recommendations) ? state.recommendations : [];
      elements.recommendationsList.innerHTML = items.map((msg) => `<li>${escapeHtml(msg)}</li>`).join('');
    }

    function saveSettings() {
      try {
        const payload = {
          from: elements.fromInput.value,
          to: elements.toInput.value,
          weight: elements.weightToggle.checked,
          platon: elements.platonToggle.checked,
          toll: elements.tollToggle.checked,
          simplify: elements.simplifyToggle ? elements.simplifyToggle.checked : true,
          mapMode: state.mapMode, // CHANGE: Сохраняем выбранный режим карты
        };
        localStorage.setItem('truckMapSettings', JSON.stringify(payload));
      } catch (e) { console.warn('Не удалось сохранить настройки', e); }
    }
    function restoreUI() {
      try {
        if (elements.simplifyToggle) elements.simplifyToggle.checked = true;
        const raw = localStorage.getItem('truckMapSettings');
        if (!raw) {
          elements.weightToggle.checked = true;
          if (elements.mapModeSelect) elements.mapModeSelect.value = state.mapMode; // CHANGE: Значение селектора по умолчанию
          return;
        }
        const data = JSON.parse(raw);
        if (typeof data.from === 'string') elements.fromInput.value = data.from;
        if (typeof data.to === 'string') elements.toInput.value = data.to;
        elements.weightToggle.checked = data.weight !== undefined ? data.weight : true;
        if (typeof data.platon === 'boolean') elements.platonToggle.checked = data.platon;
        if (typeof data.toll === 'boolean') elements.tollToggle.checked = data.toll;
        if (typeof data.simplify === 'boolean' && elements.simplifyToggle) elements.simplifyToggle.checked = data.simplify;
        if (typeof data.mapMode === 'string') {
          state.mapMode = data.mapMode; // CHANGE: Восстановление сохранённого режима карты
        }
        if (elements.mapModeSelect) {
          elements.mapModeSelect.value = state.mapMode;
        }
      } catch (e) {
        console.warn('Не удалось восстановить настройки', e);
        elements.weightToggle.checked = true;
        if (elements.simplifyToggle) elements.simplifyToggle.checked = true;
        if (elements.mapModeSelect) elements.mapModeSelect.value = state.mapMode;
      }
    }

    // -------- Utils
    function getOffsetPoint(point, center, offset){ if(!point||!center) return null; const bearing = bearingBetween(point, center); return destinationPoint(point, reverseBearing(bearing), offset); }
    function selectEvenly(arr, n){ if(!Array.isArray(arr) || !arr.length) return []; const count = Math.max(1, Math.min(n || 1, arr.length)); if (count === 1) return [arr[0]]; const out = []; for (let i = 0; i < count; i += 1){ const idx = Math.round((i*(arr.length-1))/(count-1)); out.push(arr[idx]); } return out; }
    function formatDistance(value){ if (!Number.isFinite(value)) return '—'; const sign = value < 0 ? -1 : 1; const abs = Math.abs(value); const formatted = abs >= 1000 ? `${(abs/1000).toFixed(1)} км` : `${Math.round(abs)} м`; return sign < 0 ? `-${formatted}` : formatted; }
    function formatDuration(value){ if (!Number.isFinite(value)) return '—'; const sign = value < 0 ? -1 : 1; const absSeconds = Math.abs(value); if (absSeconds < 60) return sign < 0 ? '-<1 мин' : '<1 мин'; const totalMinutes = Math.round(absSeconds / 60); const hours = Math.floor(totalMinutes / 60); const minutes = totalMinutes % 60; const formatted = hours > 0 ? `${hours} ч ${minutes} мин` : `${minutes} мин`; return sign < 0 ? `-${formatted}` : formatted; }
    function formatStep(step){ if (!step) return 'Двигайтесь прямо'; const maneuver = step.maneuver && (step.maneuver.instruction || step.maneuver.type); const base = maneuver || 'Двигайтесь'; const name = step.name ? ` на ${step.name}` : ''; return base + name; }
    function delay(ms){ return new Promise((res) => setTimeout(res, ms)); }
    function escapeHtml(str){ return String(str).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
    function debounce(fn, wait){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,args), wait); }; }
    function toRad(deg){ return deg * Math.PI / 180; } function toDeg(rad){ return rad * 180 / Math.PI; }
    function normalizeLon(lon){ while (lon > 180) lon -= 360; while (lon < -180) lon += 360; return lon; }
    function haversine(a,b){ const R=6371000, dLat=toRad(b[0]-a[0]), dLon=toRad(b[1]-a[1]), lat1=toRad(a[0]), lat2=toRad(b[0]); const h=Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(h)); }
    function bearingBetween(a,b){ const lat1=toRad(a[0]), lat2=toRad(b[0]), dLon=toRad(b[1]-a[1]); const y=Math.sin(dLon)*Math.cos(lat2); const x=Math.cos(lat1)*Math.sin(lat2)-Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon); return Math.atan2(y,x); }
    function destinationPoint(start, bearing, distance){ const R=6371000, ad=distance/R, lat1=toRad(start[0]), lon1=toRad(start[1]); const lat2=Math.asin(Math.sin(lat1)*Math.cos(ad)+Math.cos(lat1)*Math.sin(ad)*Math.cos(bearing)); const lon2=lon1+Math.atan2(Math.sin(bearing)*Math.sin(ad)*Math.cos(lat1), Math.cos(ad)-Math.sin(lat1)*Math.sin(lat2)); return [toDeg(lat2), normalizeLon(toDeg(lon2))]; }
    function reverseBearing(rad){ let x=rad+Math.PI; while(x>Math.PI) x-=2*Math.PI; while(x<=-Math.PI) x+=2*Math.PI; return x; }

    // если в проекте нет функции — добавим простую
    if (typeof pickEvenlySpacedPoints !== 'function') {
      window.pickEvenlySpacedPoints = function(path, n){
        if (!Array.isArray(path) || path.length < 2) return path || [];
        const count = Math.max(2, Math.min(n || 2, path.length));
        if (count === 2) return [path[0], path[path.length - 1]];
        const out = [];
        for (let i = 0; i < count; i += 1) {
          const idx = Math.round((i * (path.length - 1)) / (count - 1));
          out.push(path[idx]);
        }
        return out;
      }
    }

  })();
  </script>
</body>
</html>
