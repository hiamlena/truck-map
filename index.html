<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Маршруты для грузовиков</title>
  <style>
    :root {
      color-scheme: light;
      --accent: #1b6cff;
      --accent-dark: #0f4ec2;
      --danger: #ff3b30;
      --warning: #ff9500;
      --sheet-bg: rgba(255, 255, 255, 0.94);
      --panel-bg: rgba(255, 255, 255, 0.92);
      --shadow: 0 18px 44px rgba(15, 23, 42, 0.18);
      --font: "Inter", "Segoe UI", Roboto, sans-serif;
      --border: rgba(15, 23, 42, 0.08);
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: var(--font);
      background: #f3f4f8;
      color: #0f172a;
      -webkit-font-smoothing: antialiased;
    }

    body {
      position: relative;
      min-height: 100dvh;
      overflow: hidden;
      padding-bottom: env(safe-area-inset-bottom);
    }

    #map {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .panel {
      position: fixed;
      z-index: 1100;
      background: var(--panel-bg);
      box-shadow: var(--shadow);
      border-radius: 18px;
      padding: 16px 18px;
      backdrop-filter: blur(18px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .panel.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #recommendations {
      top: calc(16px + env(safe-area-inset-top));
      left: 16px;
      width: min(360px, calc(100vw - 32px));
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 42vh;
      overflow-y: auto;
    }

    #recommendations.hidden {
      transform: translateY(-24px);
    }

    #recommendations h2 {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
    }

    #recommendationsList {
      margin: 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 14px;
    }

    #legend {
      top: calc(16px + env(safe-area-inset-top));
      right: 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 200px;
      font-size: 14px;
    }

    #legend.hidden {
      transform: translateY(-24px);
    }

    #legend h2 {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
    }

    .legend-item {
      display: grid;
      grid-template-columns: 22px 1fr;
      align-items: center;
      gap: 12px;
    }

    .legend-icon {
      width: 16px;
      height: 16px;
      border-radius: 999px;
    }

    .legend-icon.red { background: var(--danger); }
    .legend-icon.orange { background: var(--warning); }
    .legend-line {
      width: 24px;
      height: 4px;
      border-radius: 999px;
      background: var(--accent);
    }

    .sheet {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1200;
      background: var(--sheet-bg);
      border-radius: 26px 26px 0 0;
      box-shadow: 0 -18px 48px rgba(15, 23, 42, 0.35);
      padding: 20px 20px calc(28px + env(safe-area-inset-bottom));
      display: flex;
      flex-direction: column;
      gap: 18px;
      max-height: 65dvh;
      transition: transform 0.35s ease;
      backdrop-filter: blur(20px);
      overflow: hidden;
    }

    .sheet.hidden {
      transform: translateY(calc(100% - 72px));
    }

    .sheet::before {
      content: "";
      width: 58px;
      height: 5px;
      background: rgba(15, 23, 42, 0.25);
      border-radius: 999px;
      align-self: center;
      margin-top: -4px;
    }

    form {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .field label {
      font-size: 14px;
      font-weight: 600;
    }

    .field input {
      padding: 14px 16px;
      border-radius: 14px;
      border: 1px solid var(--border);
      font-size: 16px;
      background: rgba(255, 255, 255, 0.95);
      color: inherit;
    }

    .field input:focus {
      outline: 2px solid rgba(27, 108, 255, 0.35);
      outline-offset: 1px;
    }

    .toggles {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      font-size: 14px;
    }

    .toggles label {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.06);
    }

    .actions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
    }

    button {
      font-family: var(--font);
    }

    .actions button {
      padding: 14px;
      border-radius: 16px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      color: #fff;
      background: var(--accent);
      box-shadow: 0 12px 30px rgba(27, 108, 255, 0.25);
      transition: transform 0.16s ease, box-shadow 0.16s ease, background 0.16s ease;
    }

    .actions button.secondary {
      background: #1f2937;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.25);
    }

    .actions button.danger {
      background: var(--danger);
      box-shadow: 0 12px 30px rgba(255, 59, 48, 0.25);
    }

    .actions button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .steps {
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.06);
      padding: 12px 16px 16px;
      max-height: 180px;
      overflow-y: auto;
    }

    .steps[hidden] {
      display: none;
    }

    .steps h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
      font-weight: 700;
    }

    .steps ol {
      margin: 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 14px;
    }

    .steps li.active {
      color: var(--accent-dark);
      font-weight: 600;
    }

    .panel-toggle {
      position: fixed;
      top: calc(env(safe-area-inset-top) + 16px);
      right: 16px;
      z-index: 1500;
      padding: 10px 14px;
      border-radius: 999px;
      border: none;
      background: rgba(15, 23, 42, 0.85);
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.35);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    #recommendationsToggleBtn.panel-toggle {
      right: auto;
      left: 16px;
    }

    .sheet-toggle {
      top: auto;
      bottom: calc(72px + env(safe-area-inset-bottom));
      left: 50%;
      transform: translateX(-50%);
      background: rgba(27, 108, 255, 0.92);
    }

    .panel-toggle:active {
      transform: scale(0.96);
      box-shadow: none;
    }

    .ymaps-suggest__container {
      z-index: 4000 !important;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        color-scheme: dark;
        --sheet-bg: rgba(18, 25, 38, 0.92);
        --panel-bg: rgba(18, 25, 38, 0.92);
        --border: rgba(255, 255, 255, 0.08);
        --accent: #6aa3ff;
        --accent-dark: #98c2ff;
      }

      html, body {
        background: #0b1220;
        color: #e2e8f0;
      }

      .field input {
        background: rgba(13, 19, 32, 0.9);
        color: inherit;
        border-color: rgba(148, 163, 184, 0.18);
      }

      .toggles label {
        background: rgba(148, 163, 184, 0.18);
      }

      .actions button.secondary {
        background: rgba(15, 23, 42, 0.85);
      }
    }

    @media (min-width: 768px) {
      #recommendations {
        max-height: 50vh;
      }

      .sheet {
        width: min(520px, 92vw);
        left: auto;
        right: 24px;
        bottom: 32px;
        border-radius: 26px;
        max-height: 78vh;
      }

      .sheet.hidden {
        transform: translateY(calc(100% - 88px));
      }

      .sheet-toggle {
        bottom: calc(32px + env(safe-area-inset-bottom));
      }
    }
  </style>
  <script src="https://api-maps.yandex.ru/2.1/?apikey=292c3277-6b44-4b1d-88db-813ff4caa159&lang=ru_RU"></script>
</head>
<body>
  <div id="map"></div>
  <div id="loading" hidden>Загрузка...</div>

  <button type="button" class="panel-toggle" id="legendToggleBtn">Скрыть легенду</button>
  <button type="button" class="panel-toggle" id="recommendationsToggleBtn">Скрыть рекомендации</button>
  <button type="button" class="panel-toggle sheet-toggle" id="sheetToggleBtn">Свернуть панель</button>

  <section id="recommendations" class="panel">
    <h2>Рекомендации</h2>
    <ul id="recommendationsList">
      <li>Постройте маршрут, чтобы получить рекомендации по рейсу.</li>
    </ul>
  </section>

  <aside id="legend" class="panel">
    <h2>Легенда</h2>
    <div class="legend-item"><span class="legend-icon red"></span> <span>Весовые рамки</span></div>
    <div class="legend-item"><span class="legend-icon orange"></span> <span>Платон</span></div>
    <div class="legend-item"><span class="legend-line"></span> <span>Основной маршрут</span></div>
  </aside>

  <div class="sheet" id="bottomSheet">
    <form id="routeForm">
      <div class="field">
        <label for="fromInput">Откуда</label>
        <input id="fromInput" type="text" placeholder="Адрес или широта,долгота" autocomplete="off" />
      </div>
      <div class="field">
        <label for="toInput">Куда</label>
        <input id="toInput" type="text" placeholder="Адрес или широта,долгота" autocomplete="off" />
      </div>
      <div class="toggles">
        <label><input type="checkbox" id="weightToggle" checked /> Весовые рамки</label>
        <label><input type="checkbox" id="platonToggle" /> Платон</label>
        <label><input type="checkbox" id="tollToggle" /> Избегать платных дорог</label>
        <label><input type="checkbox" id="simplifyToggle" checked /> Упрощённые шаги</label>
      </div>
      <div class="actions">
        <button type="submit" id="buildRouteBtn">Построить маршрут</button>
        <button type="button" class="secondary" id="detourBtn">ИИ-объезд</button>
        <button type="button" class="danger" id="clearBtn">Очистить</button>
        <button type="button" class="secondary" id="gpxBtn">GPX экспорт</button>
        <button type="button" class="secondary" id="shareBtn">Поделиться</button>
        <button type="button" class="secondary" id="locateBtn">Моя позиция</button>
      </div>
    </form>
    <div class="steps" id="stepsBlock" hidden>
      <h3>Пошаговая навигация</h3>
      <ol id="stepsList"></ol>
    </div>
  </div>

  <script>
    (() => {
      const state = {
        map: null,
        routeLine: null,
        detourLine: null,
        routeMarkers: [],
        routeData: null,
        routeHistory: [],
        weightZones: [],
        platonZones: [],
        detourList: [],
        voiceQueue: [],
        speaking: false,
        currentStepIndex: 0,
        watchId: null,
        recommendations: [],
        activeRouteKind: 'main',
      };

      const zoneCache = new Map();

      const elements = {
        fromInput: document.getElementById('fromInput'),
        toInput: document.getElementById('toInput'),
        weightToggle: document.getElementById('weightToggle'),
        platonToggle: document.getElementById('platonToggle'),
        tollToggle: document.getElementById('tollToggle'),
        form: document.getElementById('routeForm'),
        detourBtn: document.getElementById('detourBtn'),
        clearBtn: document.getElementById('clearBtn'),
        gpxBtn: document.getElementById('gpxBtn'),
        shareBtn: document.getElementById('shareBtn'),
        locateBtn: document.getElementById('locateBtn'),
        stepsBlock: document.getElementById('stepsBlock'),
        stepsList: document.getElementById('stepsList'),
        simplifyToggle: document.getElementById('simplifyToggle'),
        recommendations: document.getElementById('recommendations'),
        recommendationsList: document.getElementById('recommendationsList'),
        legend: document.getElementById('legend'),
        sheet: document.getElementById('bottomSheet'),
        legendToggleBtn: document.getElementById('legendToggleBtn'),
        recommendationsToggleBtn: document.getElementById('recommendationsToggleBtn'),
        sheetToggleBtn: document.getElementById('sheetToggleBtn'),
        loading: document.getElementById('loading'),
      };

      let tollWarned = false;
      let loadingCounter = 0;

      if (elements.loading) {
        elements.loading.hidden = true;
        elements.loading.style.display = 'none';
      }

      function showLoading() {
        loadingCounter += 1;
        if (elements.loading) {
          elements.loading.hidden = false;
          elements.loading.style.display = 'block';
        }
      }

      function hideLoading() {
        loadingCounter = Math.max(0, loadingCounter - 1);
        if (loadingCounter === 0 && elements.loading) {
          elements.loading.style.display = 'none';
          elements.loading.hidden = true;
        }
      }

      function syncDetourList() {
        state.detourList = [...state.weightZones, ...state.platonZones].filter((zone) => zone.__selected);
      }

      function applyZoneSelectionStyle(zone) {
        if (zone && zone.circle) {
          zone.circle.options.set('strokeWidth', zone.__selected ? 3 : 2);
          zone.circle.options.set('strokeOpacity', zone.__selected ? 0.9 : 0.6);
        }
      }

      function resetZoneSelections() {
        [...state.weightZones, ...state.platonZones].forEach((zone) => {
          zone.__selected = false;
          applyZoneSelectionStyle(zone);
        });
        syncDetourList();
      }

      updateRecommendations(true);

      initMap();

      async function initMap() {
        await new Promise((resolve) => ymaps.ready(resolve));
        state.map = new ymaps.Map('map', {
          center: [55.751574, 37.573856],
          zoom: 6,
          controls: ['zoomControl'],
        }, {
          suppressMapOpenBlock: true,
        });

        new ymaps.SuggestView('fromInput', { results: 8 });
        new ymaps.SuggestView('toInput', { results: 8 });

        restoreUI();
        await loadZonesLazy();
        bindEvents();
        applyZoneVisibility();
      }
      function bindEvents() {
        elements.form.addEventListener('submit', (event) => {
          event.preventDefault();
          buildRoute();
        });

        elements.detourBtn.addEventListener('click', handleDetour);
        elements.clearBtn.addEventListener('click', clearRoute);
        elements.gpxBtn.addEventListener('click', exportGpx);
        elements.shareBtn.addEventListener('click', shareRoute);
        elements.locateBtn.addEventListener('click', locateMe);

        elements.weightToggle.addEventListener('change', () => {
          saveSettings();
          applyZoneVisibility();
          if (state.routeData) {
            state.routeData.intersections = detectIntersections(state.routeData.path);
            updateRecommendations();
          }
        });

        elements.platonToggle.addEventListener('change', () => {
          saveSettings();
          applyZoneVisibility();
          if (state.routeData) {
            state.routeData.intersections = detectIntersections(state.routeData.path);
            updateRecommendations();
          }
        });

        elements.tollToggle.addEventListener('change', () => {
          saveSettings();
          if (elements.tollToggle.checked && !tollWarned) {
            alert('На публичном OSRM «избегать платных дорог» может игнорироваться. В ссылках Google Maps работает.');
            tollWarned = true;
          }
          if (state.routeData) {
            updateRecommendations();
          }
        });

        elements.simplifyToggle?.addEventListener('change', () => {
          saveSettings();
          if (state.routeData) {
            renderSteps(state.routeData.steps, elements.simplifyToggle.checked);
          }
        });

        elements.fromInput.addEventListener('input', debounce(saveSettings, 400));
        elements.toInput.addEventListener('input', debounce(saveSettings, 400));

        elements.legendToggleBtn.addEventListener('click', () => togglePanel(elements.legend, elements.legendToggleBtn, 'легенду'));
        elements.recommendationsToggleBtn.addEventListener('click', () => togglePanel(elements.recommendations, elements.recommendationsToggleBtn, 'рекомендации'));
        elements.sheetToggleBtn.addEventListener('click', () => togglePanel(elements.sheet, elements.sheetToggleBtn, 'панель'));

        if (state.map) {
          state.map.events.add('boundschange', debounce(() => {
            redrawZonesInView();
          }, 250));
        }
      }

      function togglePanel(panel, button, label) {
        panel.classList.toggle('hidden');
        const hidden = panel.classList.contains('hidden');
        button.textContent = hidden ? `Показать ${label}` : `Скрыть ${label}`;
      }
      async function loadZonesLazy() {
        if (!state.map) return;
        const requests = [
          loadGeoJson('weigh_frames.geojson', {
            color: '#ff3b30',
            fillColor: 'rgba(255, 59, 48, 0.18)',
            defaultRadius: 500,
            target: state.weightZones,
            type: 'weight',
          }),
          loadGeoJson('platon.geojson', {
            color: '#ff9500',
            fillColor: 'rgba(255, 149, 0, 0.18)',
            defaultRadius: 300,
            target: state.platonZones,
            type: 'platon',
          }),
        ];
        await Promise.all(requests);
        redrawZonesInView();
      }

      async function loadGeoJson(url, options) {
        if (zoneCache.has(url)) {
          options.target.splice(0, options.target.length, ...cloneZones(zoneCache.get(url)));
          return;
        }
        try {
          const response = await fetch(url, { cache: 'no-store' });
          if (!response.ok) {
            console.warn('Не удалось загрузить', url);
            return;
          }
          const data = await response.json();
          if (!Array.isArray(data.features)) return;
          const zones = data.features
            .filter((feature) => feature.geometry && feature.geometry.type === 'Point')
            .map((feature) => {
              const [lon, lat] = feature.geometry.coordinates;
              const props = feature.properties || {};
              const radius = Number(props.radius_m) || options.defaultRadius;
              return {
                type: options.type,
                center: [lat, lon],
                radius,
                color: options.color,
                fillColor: options.fillColor,
                properties: {
                  name: props.name || 'Без названия',
                  road: props.road || '',
                  km: props.km || '',
                  note: props.note || '',
                },
                placemark: null,
                circle: null,
                rendered: false,
                __selected: false,
              };
            });
          zoneCache.set(url, zones);
          options.target.splice(0, options.target.length, ...cloneZones(zones));
        } catch (error) {
          console.warn('Ошибка загрузки GeoJSON', error);
        }
      }

      function cloneZones(zones) {
        return zones.map((zone) => ({
          ...zone,
          properties: { ...zone.properties },
          placemark: null,
          circle: null,
          rendered: false,
          __selected: Boolean(zone.__selected),
        }));
      }
      function redrawZonesInView() {
        if (!state.map) return;
        const bounds = state.map.getBounds();
        if (!bounds) return;
        const [[southLat, westLon], [northLat, eastLon]] = bounds;
        const minLat = Math.min(southLat, northLat);
        const maxLat = Math.max(southLat, northLat);
        const minLon = Math.min(westLon, eastLon);
        const maxLon = Math.max(westLon, eastLon);
        const showWeight = elements.weightToggle.checked;
        const showPlaton = elements.platonToggle.checked;

        const inBounds = (point) => {
          const [lat, lon] = point;
          return lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon;
        };

        const processZone = (zone, visible) => {
          const shouldRender = visible && inBounds(zone.center);
          if (shouldRender && !zone.rendered) {
            const balloon = buildBalloon(zone.properties);
            zone.placemark = new ymaps.Placemark(zone.center, {
              balloonContent: balloon,
              hintContent: zone.properties.name,
            }, {
              preset: 'islands#dotIcon',
              iconColor: zone.color,
            });
            zone.circle = new ymaps.Circle([zone.center, zone.radius], {}, {
              fillColor: zone.fillColor,
              strokeColor: zone.color,
              strokeWidth: zone.__selected ? 3 : 2,
              strokeOpacity: zone.__selected ? 0.9 : 0.6,
              fillOpacity: 0.35,
            });
            state.map.geoObjects.add(zone.circle);
            state.map.geoObjects.add(zone.placemark);
            const toggleSelection = () => {
              if (!state.routeData) {
                alert('Сначала постройте маршрут.');
                return;
              }
              zone.__selected = !zone.__selected;
              applyZoneSelectionStyle(zone);
              syncDetourList();
              const label = zone.properties?.name || 'Без названия';
              console.log(`Зона для объезда: ${label} (${zone.__selected ? 'выбрана' : 'снята'})`);
            };
            zone.circle.events.add('click', toggleSelection);
            zone.placemark.events.add('click', toggleSelection);
            applyZoneSelectionStyle(zone);
            zone.rendered = true;
          } else if (shouldRender && zone.rendered) {
            applyZoneSelectionStyle(zone);
          } else if (!shouldRender && zone.rendered) {
            if (zone.circle) state.map.geoObjects.remove(zone.circle);
            if (zone.placemark) state.map.geoObjects.remove(zone.placemark);
            zone.circle = null;
            zone.placemark = null;
            zone.rendered = false;
          }
        };

        state.weightZones.forEach((zone) => processZone(zone, showWeight));
        state.platonZones.forEach((zone) => processZone(zone, showPlaton));
      }

      function applyZoneVisibility() {
        redrawZonesInView();
        syncDetourList();
      }

      function buildBalloon(props) {
        const lines = [];
        lines.push(`<strong>${escapeHtml(props.name)}</strong>`);
        const roadParts = [];
        if (props.road) roadParts.push(escapeHtml(props.road));
        if (props.km) roadParts.push(`км ${escapeHtml(String(props.km))}`);
        if (roadParts.length) {
          lines.push(roadParts.join(', '));
        }
        if (props.note) {
          lines.push(`Объезд: ${escapeHtml(props.note)}`);
        }
        return lines.join('<br />');
      }
      async function buildRoute(options = {}) {
        showLoading();
        try {
          const fromValue = options.from ?? elements.fromInput.value.trim();
          const toValue = options.to ?? elements.toInput.value.trim();
          if (!fromValue || !toValue) {
            alert('Укажите точки начала и конца маршрута.');
            return;
          }

          const from = await resolveInput(fromValue);
          const to = await resolveInput(toValue);
          const viaRaw = Array.isArray(options.via) ? options.via : [];
          if (!from || !to) {
            alert('Не удалось определить координаты. Проверьте введённые данные.');
            return;
          }

          const viaResolved = [];
          for (const v of viaRaw) {
            const point = await resolveInput(v);
            if (point) viaResolved.push(point);
          }

          const coordsList = [from, ...viaResolved, to];
          const avoidToll = Boolean(elements.tollToggle.checked);
          const routeData = await requestRouteWithRetry(coordsList, avoidToll, 2);
          if (!routeData) {
            alert('Маршрут не найден. Попробуйте изменить точки.');
            return;
          }

          if (state.routeData) {
            state.routeHistory.push(state.routeData);
          }

          state.routeData = {
            coordsList,
            path: routeData.path,
            distance: routeData.distance,
            duration: routeData.duration,
            steps: routeData.steps,
            intersections: detectIntersections(routeData.path),
          };

          state.activeRouteKind = 'main';
          clearDetour();
          resetZoneSelections();

          renderRoute(routeData.path, coordsList);
          renderSteps(routeData.steps, elements.simplifyToggle?.checked);
          speakSteps(routeData.steps);
          updateRecommendations();
        } catch (error) {
          console.warn(error);
          alert(error && error.message ? error.message : 'Не удалось построить маршрут. Попробуйте ещё раз.');
        } finally {
          hideLoading();
        }
      }

      async function requestRouteWithRetry(coordsList, avoidToll, attempts = 2) {
        let lastError = null;
        for (let i = 0; i < attempts; i += 1) {
          try {
            return await requestRoute(coordsList, avoidToll);
          } catch (error) {
            lastError = error;
            if (i < attempts - 1) {
              await delay(700);
            }
          }
        }
        throw lastError || new Error('Не удалось получить маршрут.');
      }

      async function requestRoute(coordsList, avoidToll) {
        const points = coordsList.map((coord) => `${coord[1]},${coord[0]}`).join(';');
        const url = new URL(`https://router.project-osrm.org/route/v1/driving/${points}`);
        url.searchParams.set('overview', 'full');
        url.searchParams.set('geometries', 'geojson');
        url.searchParams.set('steps', 'true');
        if (avoidToll) {
          url.searchParams.set('exclude', 'toll');
        }
        const response = await fetch(url.toString());
        if (!response.ok) {
          throw new Error('Сервис маршрутов временно недоступен.');
        }
        const data = await response.json();
        if (!data.routes || !data.routes.length) {
          return null;
        }
        const route = data.routes[0];
        const path = route.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
        const steps = [];
        route.legs.forEach((leg) => {
          leg.steps.forEach((step) => {
            steps.push({
              text: step.maneuver.instruction || formatStep(step),
              distance: step.distance,
              duration: step.duration,
              name: step.name || '',
              maneuver: step.maneuver || null,
            });
          });
        });
        return {
          path,
          steps,
          distance: route.distance,
          duration: route.duration,
        };
      }
      async function handleDetour() {
        showLoading();
        try {
          if (!state.routeData) {
            alert('Сначала постройте маршрут.');
            return;
          }

          const baseRoute = state.routeData;
          const path = Array.isArray(baseRoute.path) ? baseRoute.path : [];
          if (path.length < 2) {
            alert('Недостаточно данных маршрута для расчёта объезда.');
            return;
          }

          const selectedZones = Array.isArray(state.detourList) && state.detourList.length
            ? state.detourList.slice()
            : (baseRoute.intersections || []).map((hit) => hit.zone).filter(Boolean);

          const uniqueZones = [];
          const zoneSet = new Set();
          selectedZones.forEach((zone) => {
            if (zone && !zoneSet.has(zone)) {
              zoneSet.add(zone);
              uniqueZones.push(zone);
            }
          });

          if (!uniqueZones.length) {
            alert('Зоны на маршруте не обнаружены.');
            return;
          }

          const viaCandidates = [];
          uniqueZones.forEach((zone) => {
            if (!zone || !Array.isArray(zone.center)) return;
            let closest = null;
            for (let i = 0; i < path.length - 1; i += 1) {
              const start = path[i];
              const end = path[i + 1];
              const projection = projectPointOnSegment(zone.center, start, end);
              if (!projection) continue;
              if (!closest || projection.distance < closest.distance) {
                closest = { ...projection };
              }
            }
            if (closest) {
              const radius = Number(zone.radius) || 0;
              const offset = radius * 0.8 + 300;
              const bearing = bearingBetween(closest.point, zone.center);
              const viaPoint = destinationPoint(closest.point, reverseBearing(bearing), offset);
              if (!viaCandidates.some((existing) => nearlyEqualPoints(existing, viaPoint))) {
                viaCandidates.push(viaPoint);
              }
            }
          });

          if (!viaCandidates.length) {
            alert('Не удалось вычислить точки объезда.');
            return;
          }

          const via = selectEvenly(viaCandidates, 6);
          console.log('ИИ-объезд via-точки:', via);

          const coordsList = Array.isArray(baseRoute.coordsList) ? baseRoute.coordsList : [];
          if (coordsList.length < 2) {
            alert('Не удалось определить точки маршрута.');
            return;
          }

          const start = coordsList[0];
          const finish = coordsList[coordsList.length - 1];

          await buildRoute({ from: start, to: finish, via });
        } catch (error) {
          console.warn('Ошибка построения объезда', error);
          alert('Не удалось построить альтернативный маршрут. Попробуйте позже.');
        } finally {
          hideLoading();
        }
      }

      function renderRoute(path, coordsList) {
        state.activeRouteKind = 'main';
        if (state.routeLine) {
          state.map.geoObjects.remove(state.routeLine);
        }
        state.routeMarkers.forEach((marker) => state.map.geoObjects.remove(marker));
        state.routeMarkers = [];

        state.routeLine = new ymaps.Polyline(path, {}, {
          strokeColor: '#1b6cff',
          strokeWidth: 6,
          strokeOpacity: 0.95,
        });
        state.map.geoObjects.add(state.routeLine);

        coordsList.forEach((coord, idx) => {
          const caption = idx === 0 ? 'Старт' : (idx === coordsList.length - 1 ? 'Финиш' : `Точка ${idx}`);
          const marker = new ymaps.Placemark(coord, {
            iconCaption: caption,
          }, {
            preset: 'islands#blueCircleIcon',
          });
          state.routeMarkers.push(marker);
          state.map.geoObjects.add(marker);
        });

        const bounds = state.routeLine.geometry.getBounds();
        if (bounds) {
          state.map.setBounds(bounds, {
            checkZoomRange: true,
            zoomMargin: [40, 240, 240, 40],
          });
        }
      }

      function drawDetour(coords) {
        clearDetour();
        if (!state.map || !Array.isArray(coords) || !coords.length) return;
        state.detourLine = new ymaps.Polyline(coords, {}, {
          strokeColor: '#9e9e9e',
          strokeWidth: 5,
          strokeOpacity: 0.9,
          strokeStyle: 'shortdash',
        });
        state.map.geoObjects.add(state.detourLine);
      }

      function clearDetour() {
        if (state.detourLine && state.map) {
          state.map.geoObjects.remove(state.detourLine);
        }
        state.detourLine = null;
      }

      function renderSteps(steps, simplify = false) {
        const list = elements.stepsList;
        list.innerHTML = '';
        state.currentStepIndex = 0;

        if (!Array.isArray(steps) || !steps.length) {
          elements.stepsBlock.hidden = true;
          return;
        }

        const noiseTypes = new Set(['depart', 'arrive', 'new name', 'end of road']);

        const prepared = steps.map((step, idx) => {
          const ref = step || {};
          const localized = getLocalizedInstruction(ref);
          ref.localizedText = localized || (ref.text || '').trim();
          const type = (ref.maneuver?.type || ref.type || '').toLowerCase();
          return {
            originalIndex: idx,
            type,
            distance: Number(ref.distance) || 0,
            duration: Number(ref.duration) || 0,
            displayText: ref.localizedText || 'Двигайтесь прямо',
          };
        });

        const filtered = prepared.filter((item) => {
          if (noiseTypes.has(item.type)) return false;
          const original = steps[item.originalIndex] || {};
          const text = (original.text || '').toLowerCase();
          if (!item.type && (text.includes('depart') || text.includes('arrive') || text.includes('new name') || text.includes('end of road'))) {
            return false;
          }
          if ((item.type === 'roundabout' || item.type === 'rotary' || item.type === 'roundabout turn') && item.distance < 80) return false;
          if (simplify && item.distance < 120) return false;
          return Boolean(item.displayText);
        });

        const merged = [];
        filtered.forEach((item) => {
          const last = merged[merged.length - 1];
          if (last && last.displayText === item.displayText) {
            last.distance += item.distance;
            last.duration += item.duration;
            last.indices.push(item.originalIndex);
          } else {
            merged.push({
              displayText: item.displayText,
              distance: item.distance,
              duration: item.duration,
              indices: [item.originalIndex],
            });
          }
        });

        if (!merged.length) {
          elements.stepsBlock.hidden = true;
          return;
        }

        merged.forEach((item, idx) => {
          const li = document.createElement('li');
          li.textContent = `${item.displayText} (${formatDistance(item.distance)}, ${formatDuration(item.duration)})`;
          const indices = item.indices && item.indices.length ? item.indices : [idx];
          li.dataset.originalIndex = String(indices[0]);
          li.dataset.originalIndices = indices.join(',');
          li.dataset.listIndex = String(idx);
          list.appendChild(li);
        });

        elements.stepsBlock.hidden = false;
        list.firstElementChild?.classList.add('active');
      }

      function getLocalizedInstruction(step) {
        if (!step) return '';
        const rawText = (step.text || '').trim();
        const maneuver = step.maneuver || {};
        const type = (maneuver.type || step.type || '').toLowerCase();
        const modifier = (maneuver.modifier || step.modifier || '').toLowerCase();
        const name = (step.name || '').trim();
        const exit = maneuver.exit;
        const roadOn = name ? ` на ${name}` : '';
        const roadAlong = name ? ` по ${name}` : '';

        switch (type) {
          case 'turn': {
            if (modifier === 'uturn') return `Развернитесь${roadOn}`;
            const dir = getDirectionText(modifier);
            return dir ? `Поверните ${dir}${roadOn}` : `Поверните${roadOn}`;
          }
          case 'fork': {
            const lane = getLaneDirection(modifier);
            return lane ? `Держитесь ${lane}${roadAlong}` : `Держитесь${roadAlong}`;
          }
          case 'merge': {
            const lane = getLaneDirection(modifier);
            return lane ? `Перестройтесь ${lane}${roadAlong}` : `Перестройтесь${roadAlong}`;
          }
          case 'off ramp':
          case 'on ramp':
          case 'ramp':
          case 'exit': {
            if (modifier === 'uturn') return `Развернитесь${roadOn}`;
            const dir = getDirectionText(modifier);
            return dir ? `Съезд ${dir}${roadOn}` : `Съезд${roadOn}`;
          }
          case 'roundabout':
          case 'roundabout turn':
          case 'rotary': {
            const exitText = exit ? `${exit}-й съезд` : 'нужный съезд';
            return `На кольцевой развязке используйте ${exitText}${roadOn}`;
          }
          case 'continue': {
            if (modifier === 'uturn') return `Развернитесь${roadOn}`;
            if (modifier === 'straight' || !modifier) {
              return `Продолжайте движение${roadAlong}`;
            }
            const lane = getLaneDirection(modifier);
            if (lane) return `Продолжайте движение, держитесь ${lane}${roadAlong}`;
            const dir = getDirectionText(modifier);
            return dir ? `Продолжайте движение ${dir}${roadAlong}` : `Продолжайте движение${roadAlong}`;
          }
          default:
            break;
        }

        if (rawText) return rawText;
        return name ? `Двигайтесь по ${name}` : '';
      }

      function getDirectionText(modifier) {
        switch (modifier) {
          case 'left':
            return 'налево';
          case 'right':
            return 'направо';
          case 'sharp_left':
            return 'резко налево';
          case 'sharp_right':
            return 'резко направо';
          case 'slight_left':
            return 'плавно налево';
          case 'slight_right':
            return 'плавно направо';
          case 'straight':
            return 'прямо';
          case 'uturn':
            return 'на разворот';
          default:
            return '';
        }
      }

      function getLaneDirection(modifier) {
        switch (modifier) {
          case 'left':
            return 'левее';
          case 'right':
            return 'правее';
          case 'slight_left':
            return 'плавно левее';
          case 'slight_right':
            return 'плавно правее';
          case 'sharp_left':
            return 'резко левее';
          case 'sharp_right':
            return 'резко правее';
          case 'straight':
            return 'прямо';
          default:
            return '';
        }
      }

      function setActiveStep(index) {
        state.currentStepIndex = index;
        const items = elements.stepsList.querySelectorAll('li');
        items.forEach((item) => item.classList.remove('active'));
        const target = Number(index);
        let active = elements.stepsList.querySelector(`li[data-original-index="${target}"]`) ||
          elements.stepsList.querySelector(`li[data-list-index="${target}"]`);
        if (!active) {
          active = Array.from(items).find((item) => {
            const indices = (item.dataset.originalIndices || '')
              .split(',')
              .map((v) => Number(v.trim()))
              .filter((num) => !Number.isNaN(num));
            return indices.includes(target);
          }) || null;
        }
        if (active) {
          active.classList.add('active');
        }
      }

      function speakSteps(steps) {
        if (!('speechSynthesis' in window) || !steps || !steps.length) {
          return;
        }
        steps.forEach((step) => {
          if (!step) return;
          const localized = getLocalizedInstruction(step);
          step.localizedText = localized || (step.text || '').trim();
        });
        window.speechSynthesis.cancel();
        state.voiceQueue = steps.slice();
        state.speaking = false;
        state.currentStepIndex = 0;
        speakNext();
      }

      function speakNext() {
        if (!state.voiceQueue.length) {
          state.speaking = false;
          return;
        }
        const step = state.voiceQueue.shift();
        const index = state.routeData ? state.routeData.steps.indexOf(step) : -1;
        if (index >= 0) {
          setActiveStep(index);
        }
        const utterance = new SpeechSynthesisUtterance(step.localizedText || step.text);
        utterance.lang = 'ru-RU';
        utterance.rate = 1;
        state.speaking = true;
        utterance.onend = () => {
          const pause = Math.min(Math.max(step.duration * 1000, 2000), 8000);
          setTimeout(speakNext, pause);
        };
        window.speechSynthesis.speak(utterance);
      }
      function clearRoute() {
        if (state.routeLine) {
          state.map.geoObjects.remove(state.routeLine);
          state.routeLine = null;
        }
        resetZoneSelections();
        clearDetour();
        state.activeRouteKind = 'main';
        state.routeMarkers.forEach((marker) => state.map.geoObjects.remove(marker));
        state.routeMarkers = [];
        state.routeData = null;
        elements.stepsBlock.hidden = true;
        elements.stepsList.innerHTML = '';
        if (window.speechSynthesis && window.speechSynthesis.cancel) {
          window.speechSynthesis.cancel();
        }
        state.voiceQueue = [];
        state.recommendations = [];
        updateRecommendations(true);
      }

      function exportGpx() {
        if (!state.routeData || !state.routeData.path || !state.routeData.path.length) {
          alert('Нет данных для экспорта.');
          return;
        }
        const segments = state.routeData.path.map(([lat, lon]) => `<trkpt lat="${lat.toFixed(6)}" lon="${lon.toFixed(6)}"></trkpt>`).join('\n      ');
        const gpx = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="TruckMap" xmlns="http://www.topografix.com/GPX/1/1">\n  <trk>\n    <name>Маршрут грузовика</name>\n    <trkseg>\n      ${segments}\n    </trkseg>\n  </trk>\n</gpx>`;
        const blob = new Blob([gpx], { type: 'application/gpx+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'route.gpx';
        document.body.appendChild(link);
        link.click();
        requestAnimationFrame(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        });
      }

      function shareRoute() {
        if (!state.routeData) {
          alert('Постройте маршрут, чтобы поделиться.');
          return;
        }
        const points = pickEvenlySpacedPoints(state.routeData.path, 6);
        if (points.length < 2) {
          alert('Недостаточно точек маршрута.');
          return;
        }
        const origin = points[0];
        const destination = points[points.length - 1];
        const via = points.slice(1, -1);
        const formatPoint = (p) => `${p[0].toFixed(6)},${p[1].toFixed(6)}`;
        const googleWaypoints = via.map(formatPoint).join('|');
        const googleUrl = new URL('https://www.google.com/maps/dir/');
        googleUrl.searchParams.set('api', '1');
        googleUrl.searchParams.set('origin', formatPoint(origin));
        googleUrl.searchParams.set('destination', formatPoint(destination));
        if (googleWaypoints) {
          googleUrl.searchParams.set('waypoints', googleWaypoints);
        }
        googleUrl.searchParams.set('travelmode', 'driving');
        if (elements.tollToggle.checked) {
          googleUrl.searchParams.set('avoid', 'tolls');
        }

        const yandexPoints = points.map(formatPoint).join('~');
        const yandexUrl = `https://yandex.ru/maps/?rtext=${yandexPoints}&rtt=auto`;
        const recSummary = state.recommendations.join('\n') || 'Маршрут готов. Проверь ограничения.';
        const shareText = `Маршрут для рейса:\nGoogle Maps: ${googleUrl.toString()}\nЯндекс.Карты: ${yandexUrl}\n${recSummary}`;
        const waLink = `https://wa.me/?text=${encodeURIComponent(shareText)}`;
        window.open(waLink, '_blank');
      }

      function locateMe() {
        if (!navigator.geolocation) {
          alert('Геолокация не поддерживается вашим устройством.');
          return;
        }
        if (state.watchId) {
          navigator.geolocation.clearWatch(state.watchId);
          state.watchId = null;
        }
        const success = (position) => {
          const { latitude, longitude } = position.coords;
          const coords = [latitude, longitude];
          state.map.setCenter(coords, Math.max(state.map.getZoom(), 12), { duration: 300 });
          if (!elements.fromInput.value.trim()) {
            elements.fromInput.value = `${latitude.toFixed(6)},${longitude.toFixed(6)}`;
            saveSettings();
          }
        };
        const error = (err) => {
          console.warn(err);
          alert('Не удалось определить текущее местоположение.');
        };
        navigator.geolocation.getCurrentPosition(success, error, {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 5000,
        });
        state.watchId = navigator.geolocation.watchPosition(success, error, {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 5000,
        });
      }
      async function resolveInput(value) {
        if (Array.isArray(value) && value.length === 2) {
          const lat = Number(value[0]);
          const lon = Number(value[1]);
          if (Number.isFinite(lat) && Number.isFinite(lon)) {
            return [lat, lon];
          }
        }
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          if (Number.isFinite(value.lat) && Number.isFinite(value.lon)) {
            return [value.lat, value.lon];
          }
          if (Number.isFinite(value.latitude) && Number.isFinite(value.longitude)) {
            return [value.latitude, value.longitude];
          }
        }
        if (typeof value === 'string') {
          const parsed = parseLatLon(value);
          if (parsed) {
            return parsed;
          }
          const trimmed = value.trim();
          if (!trimmed) {
            return null;
          }
          const result = await ymaps.geocode(trimmed, { results: 1 });
          if (result.geoObjects.getLength()) {
            const coords = result.geoObjects.get(0).geometry.getCoordinates();
            return coords;
          }
        }
        return null;
      }

      function parseLatLon(str) {
        if (typeof str !== 'string') return null;
        const clean = str.trim().replace(/\s+/g, '');
        if (!clean) return null;
        const parts = clean.split(/[;,]/);
        if (parts.length !== 2) return null;
        const lat = Number(parts[0]);
        const lon = Number(parts[1]);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
        if (Math.abs(lat) > 90 || Math.abs(lon) > 180) return null;
        return [lat, lon];
      }
      function detectIntersections(path) {
        if (!path || !path.length) return [];
        const zones = [];
        if (elements.weightToggle.checked) {
          zones.push(...state.weightZones);
        }
        if (elements.platonToggle.checked) {
          zones.push(...state.platonZones);
        }
        if (!zones.length) return [];
        const hits = [];
        let traveled = 0;
        for (let i = 0; i < path.length - 1; i += 1) {
          const start = path[i];
          const end = path[i + 1];
          const segmentLength = haversineDistance(start, end);
          zones.forEach((zone) => {
            const radius = Number(zone.radius) || 0;
            if (!radius) return;
            const projection = projectPointOnSegment(zone.center, start, end);
            if (projection && projection.distance <= radius) {
              hits.push({
                zone,
                distance: traveled + projection.alongDistance,
                point: projection.point,
              });
            }
          });
          traveled += segmentLength;
        }
        hits.sort((a, b) => a.distance - b.distance);
        return hits;
      }

      function getOffsetPoint(routePoint, zoneCenter, distance) {
        if (!routePoint || !zoneCenter || !Number.isFinite(distance)) return null;
        const bearing = bearingBetween(zoneCenter, routePoint);
        return destinationPoint(zoneCenter, bearing, distance);
      }

      function selectEvenly(arr, max = 6) {
        if (!Array.isArray(arr) || !arr.length) return [];
        if (arr.length <= max) return arr;
        const out = [];
        const step = Math.max(1, Math.floor(arr.length / (max + 1)));
        for (let i = step; i < arr.length && out.length < max; i += step) {
          out.push(arr[i]);
        }
        return out;
      }

      function pickEvenlySpacedPoints(path, count) {
        if (!path || !path.length) return [];
        if (path.length <= count) {
          return path.slice();
        }
        const result = [];
        const step = (path.length - 1) / (count - 1);
        for (let i = 0; i < count; i += 1) {
          const index = Math.round(i * step);
          result.push(path[index]);
        }
        return result;
      }

      function nearlyEqualPoints(a, b) {
        return Math.abs(a[0] - b[0]) < 1e-4 && Math.abs(a[1] - b[1]) < 1e-4;
      }
      function updateRecommendations(reset = false) {
        if (reset || !state.routeData) {
          state.recommendations = ['Постройте маршрут, чтобы получить рекомендации.'];
          renderRecommendations();
          return;
        }

        const ints = Array.isArray(state.routeData.intersections) ? state.routeData.intersections : [];
        const weightCount = ints.filter((h) => h.zone.type === 'weight').length;
        const platonCount = ints.filter((h) => h.zone.type === 'platon').length;

        const msgs = [];
        if (ints.length) {
          const parts = [];
          if (weightCount) parts.push(`весовые: ${weightCount}`);
          if (platonCount) parts.push(`Платон: ${platonCount}`);
          msgs.push(`На маршруте ${ints.length} зон (${parts.join(', ')}).`);
        } else {
          msgs.push('Опасных зон на маршруте не обнаружено.');
        }

        msgs.push(`Протяжённость: ${formatDistance(state.routeData.distance)}, время: ${formatDuration(state.routeData.duration)}.`);

        if (elements.tollToggle.checked) {
          msgs.push('Включено «избегать платных дорог» (на demo-OSRM может игнорироваться).');
        }

        const prev = [...state.routeHistory].reverse().find(Boolean);
        if (prev?.distance && prev?.duration) {
          const dd = state.routeData.distance - prev.distance;
          const dt = state.routeData.duration - prev.duration;
          if (Math.abs(dd) > 500) msgs.push(`Длина ${dd > 0 ? 'увеличилась' : 'уменьшилась'} на ${formatDistance(Math.abs(dd))}.`);
          if (Math.abs(dt) > 120) msgs.push(`Время ${dt > 0 ? 'увеличилось' : 'уменьшилось'} на ${formatDuration(Math.abs(dt))}.`);
        }

        state.recommendations = msgs;
        renderRecommendations();
      }

      function renderRecommendations() {
        const items = Array.isArray(state.recommendations) ? state.recommendations : [];
        elements.recommendationsList.innerHTML = items.map((msg) => `<li>${escapeHtml(msg)}</li>`).join('');
      }

      function saveSettings() {
        try {
          const payload = {
            from: elements.fromInput.value,
            to: elements.toInput.value,
            weight: elements.weightToggle.checked,
            platon: elements.platonToggle.checked,
            toll: elements.tollToggle.checked,
            simplify: elements.simplifyToggle ? elements.simplifyToggle.checked : true,
          };
          localStorage.setItem('truckMapSettings', JSON.stringify(payload));
        } catch (error) {
          console.warn('Не удалось сохранить настройки', error);
        }
      }

      function restoreUI() {
        try {
          if (elements.simplifyToggle) {
            elements.simplifyToggle.checked = true;
          }
          const raw = localStorage.getItem('truckMapSettings');
          if (!raw) {
            elements.weightToggle.checked = true;
            return;
          }
          const data = JSON.parse(raw);
          if (typeof data.from === 'string') elements.fromInput.value = data.from;
          if (typeof data.to === 'string') elements.toInput.value = data.to;
          elements.weightToggle.checked = data.weight !== undefined ? data.weight : true;
          if (typeof data.platon === 'boolean') elements.platonToggle.checked = data.platon;
          if (typeof data.toll === 'boolean') elements.tollToggle.checked = data.toll;
          if (typeof data.simplify === 'boolean' && elements.simplifyToggle) {
            elements.simplifyToggle.checked = data.simplify;
          }
        } catch (error) {
          console.warn('Не удалось восстановить настройки', error);
          elements.weightToggle.checked = true;
          if (elements.simplifyToggle) {
            elements.simplifyToggle.checked = true;
          }
        }
      }
      function formatDistance(value) {
        if (!Number.isFinite(value)) return '—';
        const sign = value < 0 ? -1 : 1;
        const abs = Math.abs(value);
        const formatted = abs >= 1000 ? `${(abs / 1000).toFixed(1)} км` : `${Math.round(abs)} м`;
        return sign < 0 ? `-${formatted}` : formatted;
      }

      function formatDuration(value) {
        if (!Number.isFinite(value)) return '—';
        const sign = value < 0 ? -1 : 1;
        const absSeconds = Math.abs(value);
        if (absSeconds < 60) {
          return sign < 0 ? '-<1 мин' : '<1 мин';
        }
        const totalMinutes = Math.round(absSeconds / 60);
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        const formatted = hours > 0 ? `${hours} ч ${minutes} мин` : `${minutes} мин`;
        return sign < 0 ? `-${formatted}` : formatted;
      }

      function formatStep(step) {
        if (!step) return 'Двигайтесь прямо';
        const maneuver = step.maneuver && (step.maneuver.instruction || step.maneuver.type);
        const base = maneuver || 'Двигайтесь';
        const name = step.name ? ` на ${step.name}` : '';
        return base + name;
      }

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function debounce(fn, wait = 300) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn.apply(null, args), wait);
        };
      }
      function haversineDistance(a, b) {
        const R = 6371000;
        const toRad = (deg) => deg * Math.PI / 180;
        const lat1 = toRad(a[0]);
        const lat2 = toRad(b[0]);
        const dLat = toRad(b[0] - a[0]);
        const dLon = toRad(b[1] - a[1]);
        const h = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
        return 2 * R * Math.asin(Math.sqrt(h));
      }

      function bearingBetween(a, b) {
        const toRad = (deg) => deg * Math.PI / 180;
        const lat1 = toRad(a[0]);
        const lat2 = toRad(b[0]);
        const dLon = toRad(b[1] - a[1]);
        const y = Math.sin(dLon) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
        return Math.atan2(y, x);
      }

      function destinationPoint(start, bearing, distance) {
        const R = 6371000;
        const angularDistance = distance / R;
        const lat1 = toRad(start[0]);
        const lon1 = toRad(start[1]);
        const lat2 = Math.asin(Math.sin(lat1) * Math.cos(angularDistance) + Math.cos(lat1) * Math.sin(angularDistance) * Math.cos(bearing));
        const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(angularDistance) * Math.cos(lat1), Math.cos(angularDistance) - Math.sin(lat1) * Math.sin(lat2));
        return [toDeg(lat2), normalizeLon(toDeg(lon2))];
      }

      function reverseBearing(rad) {
        let x = rad + Math.PI;
        while (x > Math.PI) x -= 2 * Math.PI;
        while (x <= -Math.PI) x += 2 * Math.PI;
        return x;
      }

      function projectPointOnSegment(point, start, end) {
        const R = 6371000;
        const toRad = (deg) => deg * Math.PI / 180;
        const lat0 = toRad((start[0] + end[0]) / 2);
        const toXY = ([lat, lon]) => {
          const x = R * toRad(lon) * Math.cos(lat0);
          const y = R * toRad(lat);
          return { x, y };
        };
        const startXY = toXY(start);
        const endXY = toXY(end);
        const pointXY = toXY(point);
        const dx = endXY.x - startXY.x;
        const dy = endXY.y - startXY.y;
        const lenSq = dx * dx + dy * dy;
        if (lenSq === 0) {
          const distance = Math.hypot(pointXY.x - startXY.x, pointXY.y - startXY.y);
          return {
            point: start.slice(),
            distance,
            alongDistance: 0,
          };
        }
        const t = Math.max(0, Math.min(1, ((pointXY.x - startXY.x) * dx + (pointXY.y - startXY.y) * dy) / lenSq));
        const projX = startXY.x + dx * t;
        const projY = startXY.y + dy * t;
        const closestLat = toDeg(projY / R);
        const closestLon = toDeg(projX / (R * Math.cos(lat0)));
        const distance = Math.hypot(pointXY.x - projX, pointXY.y - projY);
        const alongDistance = Math.hypot(projX - startXY.x, projY - startXY.y);
        return {
          point: [closestLat, closestLon],
          distance,
          alongDistance,
        };
      }

      function toRad(deg) {
        return deg * Math.PI / 180;
      }

      function toDeg(rad) {
        return rad * 180 / Math.PI;
      }

      function normalizeLon(lon) {
        return ((lon + 540) % 360) - 180;
      }

    })();
  </script>
</body>
</html>
