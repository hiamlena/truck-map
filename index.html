<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Маршруты для грузовиков</title>
  <style>
    :root {
      color-scheme: light;
      --accent: #1b6cff;
      --accent-dark: #0f4ec2;
      --danger: #ff3b30;
      --warning: #ff9500;
      --sheet-bg: rgba(255, 255, 255, 0.94);
      --panel-bg: rgba(255, 255, 255, 0.92);
      --shadow: 0 18px 44px rgba(15, 23, 42, 0.18);
      --font: "Inter", "Segoe UI", Roboto, sans-serif;
      --border: rgba(15, 23, 42, 0.08);
    }

    *, *::before, *::after {
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: var(--font);
      background: #f3f4f8;
      color: #0f172a;
      -webkit-font-smoothing: antialiased;
    }

    body {
      position: relative;
      min-height: 100dvh;
      overflow: hidden;
      padding-bottom: env(safe-area-inset-bottom);
    }

    #map {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .panel {
      position: fixed;
      z-index: 1100;
      background: var(--panel-bg);
      box-shadow: var(--shadow);
      border-radius: 18px;
      padding: 16px 18px;
      backdrop-filter: blur(18px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .panel.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #recommendations {
      top: calc(16px + env(safe-area-inset-top));
      left: 16px;
      width: min(360px, calc(100vw - 32px));
      display: flex;
      flex-direction: column;
      gap: 12px;
      max-height: 42vh;
      overflow-y: auto;
    }

    #recommendations.hidden {
      transform: translateY(-24px);
    }

    #recommendations h2 {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
    }

    #recommendationsList {
      margin: 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 14px;
    }

    #legend {
      top: calc(16px + env(safe-area-inset-top));
      right: 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 200px;
      font-size: 14px;
    }

    #legend.hidden {
      transform: translateY(-24px);
    }

    #legend h2 {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
    }

    .legend-item {
      display: grid;
      grid-template-columns: 22px 1fr;
      align-items: center;
      gap: 12px;
    }

    .legend-icon {
      width: 16px;
      height: 16px;
      border-radius: 999px;
    }

    .legend-icon.red { background: var(--danger); }
    .legend-icon.orange { background: var(--warning); }
    .legend-line {
      width: 24px;
      height: 4px;
      border-radius: 999px;
      background: var(--accent);
    }

    .sheet {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1200;
      background: var(--sheet-bg);
      border-radius: 26px 26px 0 0;
      box-shadow: 0 -18px 48px rgba(15, 23, 42, 0.35);
      padding: 20px 20px calc(28px + env(safe-area-inset-bottom));
      display: flex;
      flex-direction: column;
      gap: 18px;
      max-height: 65dvh;
      transition: transform 0.35s ease;
      backdrop-filter: blur(20px);
      overflow: hidden;
    }

    .sheet.hidden {
      transform: translateY(calc(100% - 72px));
    }

    .sheet::before {
      content: "";
      width: 58px;
      height: 5px;
      background: rgba(15, 23, 42, 0.25);
      border-radius: 999px;
      align-self: center;
      margin-top: -4px;
    }

    form {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .field label {
      font-size: 14px;
      font-weight: 600;
    }

    .field input {
      padding: 14px 16px;
      border-radius: 14px;
      border: 1px solid var(--border);
      font-size: 16px;
      background: rgba(255, 255, 255, 0.95);
      color: inherit;
    }

    .field input:focus {
      outline: 2px solid rgba(27, 108, 255, 0.35);
      outline-offset: 1px;
    }

    .toggles {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      font-size: 14px;
    }

    .toggles label {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.06);
    }

    .actions {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
    }

    button {
      font-family: var(--font);
    }

    .actions button {
      padding: 14px;
      border-radius: 16px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      color: #fff;
      background: var(--accent);
      box-shadow: 0 12px 30px rgba(27, 108, 255, 0.25);
      transition: transform 0.16s ease, box-shadow 0.16s ease, background 0.16s ease;
    }

    .actions button.secondary {
      background: #1f2937;
      box-shadow: 0 12px 30px rgba(15, 23, 42, 0.25);
    }

    .actions button.danger {
      background: var(--danger);
      box-shadow: 0 12px 30px rgba(255, 59, 48, 0.25);
    }

    .actions button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .steps {
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.06);
      padding: 12px 16px 16px;
      max-height: 180px;
      overflow-y: auto;
    }

    .steps[hidden] {
      display: none;
    }

    .steps h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
      font-weight: 700;
    }

    .steps ol {
      margin: 0;
      padding-left: 18px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 14px;
    }

    .steps li.active {
      color: var(--accent-dark);
      font-weight: 600;
    }

    .panel-toggle {
      position: fixed;
      top: calc(env(safe-area-inset-top) + 16px);
      right: 16px;
      z-index: 1500;
      padding: 10px 14px;
      border-radius: 999px;
      border: none;
      background: rgba(15, 23, 42, 0.85);
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      box-shadow: 0 10px 26px rgba(15, 23, 42, 0.35);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    #recommendationsToggleBtn.panel-toggle {
      right: auto;
      left: 16px;
    }

    .sheet-toggle {
      top: auto;
      bottom: calc(72px + env(safe-area-inset-bottom));
      left: 50%;
      transform: translateX(-50%);
      background: rgba(27, 108, 255, 0.92);
    }

    .panel-toggle:active {
      transform: scale(0.96);
      box-shadow: none;
    }

    .ymaps-suggest__container {
      z-index: 4000 !important;
    }

    @media (prefers-color-scheme: dark) {
      :root {
        color-scheme: dark;
        --sheet-bg: rgba(18, 25, 38, 0.92);
        --panel-bg: rgba(18, 25, 38, 0.92);
        --border: rgba(255, 255, 255, 0.08);
        --accent: #6aa3ff;
        --accent-dark: #98c2ff;
      }

      html, body {
        background: #0b1220;
        color: #e2e8f0;
      }

      .field input {
        background: rgba(13, 19, 32, 0.9);
        color: inherit;
        border-color: rgba(148, 163, 184, 0.18);
      }

      .toggles label {
        background: rgba(148, 163, 184, 0.18);
      }

      .actions button.secondary {
        background: rgba(15, 23, 42, 0.85);
      }
    }

    @media (min-width: 768px) {
      #recommendations {
        max-height: 50vh;
      }

      .sheet {
        width: min(520px, 92vw);
        left: auto;
        right: 24px;
        bottom: 32px;
        border-radius: 26px;
        max-height: 78vh;
      }

      .sheet.hidden {
        transform: translateY(calc(100% - 88px));
      }

      .sheet-toggle {
        bottom: calc(32px + env(safe-area-inset-bottom));
      }
    }
  </style>
  <script src="https://api-maps.yandex.ru/2.1/?apikey=292c3277-6b44-4b1d-88db-813ff4caa159&lang=ru_RU"></script>
</head>
<body>
  <div id="map"></div>

  <button type="button" class="panel-toggle" id="legendToggleBtn">Скрыть легенду</button>
  <button type="button" class="panel-toggle" id="recommendationsToggleBtn">Скрыть рекомендации</button>
  <button type="button" class="panel-toggle sheet-toggle" id="sheetToggleBtn">Свернуть панель</button>

  <section id="recommendations" class="panel">
    <h2>Рекомендации</h2>
    <ul id="recommendationsList">
      <li>Постройте маршрут, чтобы получить рекомендации по рейсу.</li>
    </ul>
  </section>

  <aside id="legend" class="panel">
    <h2>Легенда</h2>
    <div class="legend-item"><span class="legend-icon red"></span> <span>Весовые рамки</span></div>
    <div class="legend-item"><span class="legend-icon orange"></span> <span>Платон</span></div>
    <div class="legend-item"><span class="legend-line"></span> <span>Основной маршрут</span></div>
  </aside>

  <div class="sheet" id="bottomSheet">
    <form id="routeForm">
      <div class="field">
        <label for="fromInput">Откуда</label>
        <input id="fromInput" type="text" placeholder="Адрес или широта,долгота" autocomplete="off" />
      </div>
      <div class="field">
        <label for="toInput">Куда</label>
        <input id="toInput" type="text" placeholder="Адрес или широта,долгота" autocomplete="off" />
      </div>
      <div class="toggles">
        <label><input type="checkbox" id="weightToggle" checked /> Весовые рамки</label>
        <label><input type="checkbox" id="platonToggle" /> Платон</label>
        <label><input type="checkbox" id="tollToggle" /> Избегать платных дорог</label>
      </div>
      <div class="actions">
        <button type="submit" id="buildRouteBtn">Построить маршрут</button>
        <button type="button" class="secondary" id="detourBtn">ИИ-объезд</button>
        <button type="button" class="danger" id="clearBtn">Очистить</button>
        <button type="button" class="secondary" id="gpxBtn">GPX экспорт</button>
        <button type="button" class="secondary" id="shareBtn">Поделиться</button>
        <button type="button" class="secondary" id="locateBtn">Моя позиция</button>
      </div>
    </form>
    <div class="steps" id="stepsBlock" hidden>
      <h3>Пошаговая навигация</h3>
      <ol id="stepsList"></ol>
    </div>
  </div>

  <script>
    (() => {
      const state = {
        map: null,
        routeLine: null,
        routeMarkers: [],
        routeData: null,
        routeHistory: [],
        weightZones: [],
        platonZones: [],
        voiceQueue: [],
        speaking: false,
        currentStepIndex: 0,
        watchId: null,
        recommendations: [],
      };

      const zoneCache = new Map();

      const elements = {
        fromInput: document.getElementById('fromInput'),
        toInput: document.getElementById('toInput'),
        weightToggle: document.getElementById('weightToggle'),
        platonToggle: document.getElementById('platonToggle'),
        tollToggle: document.getElementById('tollToggle'),
        form: document.getElementById('routeForm'),
        detourBtn: document.getElementById('detourBtn'),
        clearBtn: document.getElementById('clearBtn'),
        gpxBtn: document.getElementById('gpxBtn'),
        shareBtn: document.getElementById('shareBtn'),
        locateBtn: document.getElementById('locateBtn'),
        stepsBlock: document.getElementById('stepsBlock'),
        stepsList: document.getElementById('stepsList'),
        recommendations: document.getElementById('recommendations'),
        recommendationsList: document.getElementById('recommendationsList'),
        legend: document.getElementById('legend'),
        sheet: document.getElementById('bottomSheet'),
        legendToggleBtn: document.getElementById('legendToggleBtn'),
        recommendationsToggleBtn: document.getElementById('recommendationsToggleBtn'),
        sheetToggleBtn: document.getElementById('sheetToggleBtn'),
      };

      initMap();

      async function initMap() {
        await new Promise((resolve) => ymaps.ready(resolve));
        state.map = new ymaps.Map('map', {
          center: [55.751574, 37.573856],
          zoom: 6,
          controls: ['zoomControl'],
        }, {
          suppressMapOpenBlock: true,
        });

        new ymaps.SuggestView('fromInput', { results: 8 });
        new ymaps.SuggestView('toInput', { results: 8 });

        restoreUI();
        await loadZonesLazy();
        bindEvents();
        applyZoneVisibility();
      }
      function bindEvents() {
        elements.form.addEventListener('submit', (event) => {
          event.preventDefault();
          buildRoute();
        });

        elements.detourBtn.addEventListener('click', handleDetour);
        elements.clearBtn.addEventListener('click', clearRoute);
        elements.gpxBtn.addEventListener('click', exportGpx);
        elements.shareBtn.addEventListener('click', shareRoute);
        elements.locateBtn.addEventListener('click', locateMe);

        elements.weightToggle.addEventListener('change', () => {
          saveSettings();
          applyZoneVisibility();
          if (state.routeData) {
            state.routeData.intersections = detectIntersections(state.routeData.path);
            updateRecommendations();
          }
        });

        elements.platonToggle.addEventListener('change', () => {
          saveSettings();
          applyZoneVisibility();
          if (state.routeData) {
            state.routeData.intersections = detectIntersections(state.routeData.path);
            updateRecommendations();
          }
        });

        elements.tollToggle.addEventListener('change', () => {
          saveSettings();
          if (state.routeData) {
            updateRecommendations();
          }
        });

        elements.fromInput.addEventListener('input', debounce(saveSettings, 400));
        elements.toInput.addEventListener('input', debounce(saveSettings, 400));

        elements.legendToggleBtn.addEventListener('click', () => togglePanel(elements.legend, elements.legendToggleBtn, 'легенду'));
        elements.recommendationsToggleBtn.addEventListener('click', () => togglePanel(elements.recommendations, elements.recommendationsToggleBtn, 'рекомендации'));
        elements.sheetToggleBtn.addEventListener('click', () => togglePanel(elements.sheet, elements.sheetToggleBtn, 'панель'));

        if (state.map) {
          state.map.events.add('boundschange', debounce(() => {
            redrawZonesInView();
          }, 250));
        }
      }

      function togglePanel(panel, button, label) {
        panel.classList.toggle('hidden');
        const hidden = panel.classList.contains('hidden');
        button.textContent = hidden ? `Показать ${label}` : `Скрыть ${label}`;
      }
      async function loadZonesLazy() {
        if (!state.map) return;
        const requests = [
          loadGeoJson('weigh_frames.geojson', {
            color: '#ff3b30',
            fillColor: 'rgba(255, 59, 48, 0.18)',
            defaultRadius: 500,
            target: state.weightZones,
            type: 'weight',
          }),
          loadGeoJson('platon.geojson', {
            color: '#ff9500',
            fillColor: 'rgba(255, 149, 0, 0.18)',
            defaultRadius: 300,
            target: state.platonZones,
            type: 'platon',
          }),
        ];
        await Promise.all(requests);
        redrawZonesInView();
      }

      async function loadGeoJson(url, options) {
        if (zoneCache.has(url)) {
          options.target.splice(0, options.target.length, ...cloneZones(zoneCache.get(url)));
          return;
        }
        try {
          const response = await fetch(url, { cache: 'no-store' });
          if (!response.ok) {
            console.warn('Не удалось загрузить', url);
            return;
          }
          const data = await response.json();
          if (!Array.isArray(data.features)) return;
          const zones = data.features
            .filter((feature) => feature.geometry && feature.geometry.type === 'Point')
            .map((feature) => {
              const [lon, lat] = feature.geometry.coordinates;
              const props = feature.properties || {};
              const radius = Number(props.radius_m) || options.defaultRadius;
              return {
                type: options.type,
                center: [lat, lon],
                radius,
                color: options.color,
                fillColor: options.fillColor,
                properties: {
                  name: props.name || 'Без названия',
                  road: props.road || '',
                  km: props.km || '',
                  note: props.note || '',
                },
                placemark: null,
                circle: null,
                rendered: false,
              };
            });
          zoneCache.set(url, zones);
          options.target.splice(0, options.target.length, ...cloneZones(zones));
        } catch (error) {
          console.warn('Ошибка загрузки GeoJSON', error);
        }
      }

      function cloneZones(zones) {
        return zones.map((zone) => ({ ...zone, properties: { ...zone.properties }, placemark: null, circle: null, rendered: false }));
      }
      function redrawZonesInView() {
        if (!state.map) return;
        const bounds = state.map.getBounds();
        if (!bounds) return;
        const [[southLat, westLon], [northLat, eastLon]] = bounds;
        const minLat = Math.min(southLat, northLat);
        const maxLat = Math.max(southLat, northLat);
        const minLon = Math.min(westLon, eastLon);
        const maxLon = Math.max(westLon, eastLon);
        const showWeight = elements.weightToggle.checked;
        const showPlaton = elements.platonToggle.checked;

        const inBounds = (point) => {
          const [lat, lon] = point;
          return lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon;
        };

        const processZone = (zone, visible) => {
          const shouldRender = visible && inBounds(zone.center);
          if (shouldRender && !zone.rendered) {
            const balloon = buildBalloon(zone.properties);
            zone.placemark = new ymaps.Placemark(zone.center, {
              balloonContent: balloon,
              hintContent: zone.properties.name,
            }, {
              preset: 'islands#dotIcon',
              iconColor: zone.color,
            });
            zone.circle = new ymaps.Circle([zone.center, zone.radius], {}, {
              fillColor: zone.fillColor,
              strokeColor: zone.color,
              strokeWidth: 2,
              fillOpacity: 0.35,
            });
            state.map.geoObjects.add(zone.circle);
            state.map.geoObjects.add(zone.placemark);
            zone.rendered = true;
          } else if (!shouldRender && zone.rendered) {
            if (zone.circle) state.map.geoObjects.remove(zone.circle);
            if (zone.placemark) state.map.geoObjects.remove(zone.placemark);
            zone.circle = null;
            zone.placemark = null;
            zone.rendered = false;
          }
        };

        state.weightZones.forEach((zone) => processZone(zone, showWeight));
        state.platonZones.forEach((zone) => processZone(zone, showPlaton));
      }

      function applyZoneVisibility() {
        redrawZonesInView();
      }

      function buildBalloon(props) {
        const lines = [];
        lines.push(`<strong>${escapeHtml(props.name)}</strong>`);
        const roadParts = [];
        if (props.road) roadParts.push(escapeHtml(props.road));
        if (props.km) roadParts.push(`км ${escapeHtml(String(props.km))}`);
        if (roadParts.length) {
          lines.push(roadParts.join(', '));
        }
        if (props.note) {
          lines.push(`Объезд: ${escapeHtml(props.note)}`);
        }
        return lines.join('<br />');
      }
      async function buildRoute(options = {}) {
        try {
          const fromValue = options.from ?? elements.fromInput.value.trim();
          const toValue = options.to ?? elements.toInput.value.trim();
          if (!fromValue || !toValue) {
            alert('Укажите точки начала и конца маршрута.');
            return;
          }

          const from = await resolveInput(fromValue);
          const to = await resolveInput(toValue);
          const viaRaw = Array.isArray(options.via) ? options.via : [];
          if (!from || !to) {
            alert('Не удалось определить координаты. Проверьте введённые данные.');
            return;
          }

          const viaResolved = [];
          for (const v of viaRaw) {
            const point = await resolveInput(v);
            if (point) viaResolved.push(point);
          }

          const coordsList = [from, ...viaResolved, to];
          const avoidToll = Boolean(elements.tollToggle.checked);
          const routeData = await requestRouteWithRetry(coordsList, avoidToll, 2);
          if (!routeData) {
            alert('Маршрут не найден. Попробуйте изменить точки.');
            return;
          }

          if (state.routeData) {
            state.routeHistory.push(state.routeData);
          }

          state.routeData = {
            coordsList,
            path: routeData.path,
            distance: routeData.distance,
            duration: routeData.duration,
            steps: routeData.steps,
            intersections: detectIntersections(routeData.path),
          };

          renderRoute(routeData.path, coordsList);
          renderSteps(routeData.steps);
          speakSteps(routeData.steps);
          updateRecommendations();
        } catch (error) {
          console.warn(error);
          alert(error && error.message ? error.message : 'Не удалось построить маршрут. Попробуйте ещё раз.');
        }
      }

      async function requestRouteWithRetry(coordsList, avoidToll, attempts = 2) {
        let lastError = null;
        for (let i = 0; i < attempts; i += 1) {
          try {
            return await requestRoute(coordsList, avoidToll);
          } catch (error) {
            lastError = error;
            if (i < attempts - 1) {
              await delay(700);
            }
          }
        }
        throw lastError || new Error('Не удалось получить маршрут.');
      }

      async function requestRoute(coordsList, avoidToll) {
        const points = coordsList.map((coord) => `${coord[1]},${coord[0]}`).join(';');
        const url = new URL(`https://router.project-osrm.org/route/v1/driving/${points}`);
        url.searchParams.set('overview', 'full');
        url.searchParams.set('geometries', 'geojson');
        url.searchParams.set('steps', 'true');
        if (avoidToll) {
          url.searchParams.set('exclude', 'toll');
        }
        const response = await fetch(url.toString());
        if (!response.ok) {
          throw new Error('Сервис маршрутов временно недоступен.');
        }
        const data = await response.json();
        if (!data.routes || !data.routes.length) {
          return null;
        }
        const route = data.routes[0];
        const path = route.geometry.coordinates.map(([lon, lat]) => [lat, lon]);
        const steps = [];
        route.legs.forEach((leg) => {
          leg.steps.forEach((step) => {
            steps.push({
              text: step.maneuver.instruction || formatStep(step),
              distance: step.distance,
              duration: step.duration,
            });
          });
        });
        return {
          path,
          steps,
          distance: route.distance,
          duration: route.duration,
        };
      }
      async function handleDetour() {
        if (!state.routeData) {
          alert('Сначала постройте маршрут.');
          return;
        }
        const intersections = state.routeData.intersections;
        if (!intersections || !intersections.length) {
          alert('Опасных зон не обнаружено.');
          return;
        }

        const viaCandidates = intersections.map((hit) => {
          return getOffsetPoint(hit.point, hit.zone.center, hit.zone.radius * 1.3);
        }).filter(Boolean);

        if (!viaCandidates.length) {
          alert('Не удалось подобрать объездные точки.');
          return;
        }

        const limitedVia = selectEvenly(viaCandidates, 6);
        await buildRoute({
          from: state.routeData.coordsList[0],
          to: state.routeData.coordsList[state.routeData.coordsList.length - 1],
          via: limitedVia,
        });
      }

      function renderRoute(path, coordsList) {
        if (state.routeLine) {
          state.map.geoObjects.remove(state.routeLine);
        }
        state.routeMarkers.forEach((marker) => state.map.geoObjects.remove(marker));
        state.routeMarkers = [];

        state.routeLine = new ymaps.Polyline(path, {}, {
          strokeColor: '#1b6cff',
          strokeWidth: 6,
          strokeOpacity: 0.95,
        });
        state.map.geoObjects.add(state.routeLine);

        coordsList.forEach((coord, idx) => {
          const caption = idx === 0 ? 'Старт' : (idx === coordsList.length - 1 ? 'Финиш' : `Точка ${idx}`);
          const marker = new ymaps.Placemark(coord, {
            iconCaption: caption,
          }, {
            preset: 'islands#blueCircleIcon',
          });
          state.routeMarkers.push(marker);
          state.map.geoObjects.add(marker);
        });

        const bounds = state.routeLine.geometry.getBounds();
        if (bounds) {
          state.map.setBounds(bounds, {
            checkZoomRange: true,
            zoomMargin: [40, 240, 240, 40],
          });
        }
      }

      function renderSteps(steps) {
        if (!steps || !steps.length) {
          elements.stepsBlock.hidden = true;
          elements.stepsList.innerHTML = '';
          return;
        }
        elements.stepsBlock.hidden = false;
        elements.stepsList.innerHTML = steps.map((step, idx) => {
          return `<li data-step="${idx}"><strong>${escapeHtml(step.text)}</strong><br /><small>${formatDistance(step.distance)}, ${formatDuration(step.duration)}</small></li>`;
        }).join('');
        setActiveStep(0);
      }

      function setActiveStep(index) {
        state.currentStepIndex = index;
        const items = elements.stepsList.querySelectorAll('li');
        items.forEach((item) => item.classList.remove('active'));
        const active = elements.stepsList.querySelector(`li[data-step="${index}"]`);
        if (active) {
          active.classList.add('active');
        }
      }

      function speakSteps(steps) {
        if (!('speechSynthesis' in window) || !steps || !steps.length) {
          return;
        }
        window.speechSynthesis.cancel();
        state.voiceQueue = steps.slice();
        state.speaking = false;
        state.currentStepIndex = 0;
        speakNext();
      }

      function speakNext() {
        if (!state.voiceQueue.length) {
          state.speaking = false;
          return;
        }
        const step = state.voiceQueue.shift();
        const index = state.routeData ? state.routeData.steps.indexOf(step) : -1;
        if (index >= 0) {
          setActiveStep(index);
        }
        const utterance = new SpeechSynthesisUtterance(step.text);
        utterance.lang = 'ru-RU';
        utterance.rate = 1;
        state.speaking = true;
        utterance.onend = () => {
          const pause = Math.min(Math.max(step.duration * 1000, 2000), 8000);
          setTimeout(speakNext, pause);
        };
        window.speechSynthesis.speak(utterance);
      }
      function clearRoute() {
        if (state.routeLine) {
          state.map.geoObjects.remove(state.routeLine);
          state.routeLine = null;
        }
        state.routeMarkers.forEach((marker) => state.map.geoObjects.remove(marker));
        state.routeMarkers = [];
        state.routeData = null;
        elements.stepsBlock.hidden = true;
        elements.stepsList.innerHTML = '';
        if (window.speechSynthesis && window.speechSynthesis.cancel) {
          window.speechSynthesis.cancel();
        }
        state.voiceQueue = [];
        state.recommendations = [];
        elements.recommendationsList.innerHTML = '<li>Маршрут очищен. Постройте новый маршрут.</li>';
      }

      function exportGpx() {
        if (!state.routeData || !state.routeData.path || !state.routeData.path.length) {
          alert('Нет данных для экспорта.');
          return;
        }
        const segments = state.routeData.path.map(([lat, lon]) => `<trkpt lat="${lat.toFixed(6)}" lon="${lon.toFixed(6)}"></trkpt>`).join('\n      ');
        const gpx = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="TruckMap" xmlns="http://www.topografix.com/GPX/1/1">\n  <trk>\n    <name>Маршрут грузовика</name>\n    <trkseg>\n      ${segments}\n    </trkseg>\n  </trk>\n</gpx>`;
        const blob = new Blob([gpx], { type: 'application/gpx+xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'route.gpx';
        document.body.appendChild(link);
        link.click();
        requestAnimationFrame(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        });
      }

      function shareRoute() {
        if (!state.routeData) {
          alert('Постройте маршрут, чтобы поделиться.');
          return;
        }
        const points = pickEvenlySpacedPoints(state.routeData.path, 6);
        if (points.length < 2) {
          alert('Недостаточно точек маршрута.');
          return;
        }
        const origin = points[0];
        const destination = points[points.length - 1];
        const via = points.slice(1, -1);
        const formatPoint = (p) => `${p[0].toFixed(6)},${p[1].toFixed(6)}`;
        const googleWaypoints = via.map(formatPoint).join('|');
        const googleUrl = new URL('https://www.google.com/maps/dir/');
        googleUrl.searchParams.set('api', '1');
        googleUrl.searchParams.set('origin', formatPoint(origin));
        googleUrl.searchParams.set('destination', formatPoint(destination));
        if (googleWaypoints) {
          googleUrl.searchParams.set('waypoints', googleWaypoints);
        }
        googleUrl.searchParams.set('travelmode', 'driving');
        if (elements.tollToggle.checked) {
          googleUrl.searchParams.set('avoid', 'tolls');
        }

        const yandexPoints = points.map(formatPoint).join('~');
        const yandexUrl = `https://yandex.ru/maps/?rtext=${yandexPoints}&rtt=auto`;
        const recSummary = state.recommendations.join('\n') || 'Маршрут готов. Проверь ограничения.';
        const shareText = `Маршрут для рейса:\nGoogle Maps: ${googleUrl.toString()}\nЯндекс.Карты: ${yandexUrl}\n${recSummary}`;
        const waLink = `https://wa.me/?text=${encodeURIComponent(shareText)}`;
        window.open(waLink, '_blank');
      }

      function locateMe() {
        if (!navigator.geolocation) {
          alert('Геолокация не поддерживается вашим устройством.');
          return;
        }
        if (state.watchId) {
          navigator.geolocation.clearWatch(state.watchId);
          state.watchId = null;
        }
        const success = (position) => {
          const { latitude, longitude } = position.coords;
          const coords = [latitude, longitude];
          state.map.setCenter(coords, Math.max(state.map.getZoom(), 12), { duration: 300 });
          if (!elements.fromInput.value.trim()) {
            elements.fromInput.value = `${latitude.toFixed(6)},${longitude.toFixed(6)}`;
            saveSettings();
          }
        };
        const error = (err) => {
          console.warn(err);
          alert('Не удалось определить текущее местоположение.');
        };
        navigator.geolocation.getCurrentPosition(success, error, {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 5000,
        });
        state.watchId = navigator.geolocation.watchPosition(success, error, {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 5000,
        });
      }
      async function resolveInput(value) {
        if (Array.isArray(value) && value.length === 2) {
          const lat = Number(value[0]);
          const lon = Number(value[1]);
          if (Number.isFinite(lat) && Number.isFinite(lon)) {
            return [lat, lon];
          }
        }
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          if (Number.isFinite(value.lat) && Number.isFinite(value.lon)) {
            return [value.lat, value.lon];
          }
          if (Number.isFinite(value.latitude) && Number.isFinite(value.longitude)) {
            return [value.latitude, value.longitude];
          }
        }
        if (typeof value === 'string') {
          const parsed = parseLatLon(value);
          if (parsed) {
            return parsed;
          }
          const trimmed = value.trim();
          if (!trimmed) {
            return null;
          }
          const result = await ymaps.geocode(trimmed, { results: 1 });
          if (result.geoObjects.getLength()) {
            const coords = result.geoObjects.get(0).geometry.getCoordinates();
            return coords;
          }
        }
        return null;
      }

      function parseLatLon(str) {
        if (typeof str !== 'string') return null;
        const clean = str.trim().replace(/\s+/g, '');
        if (!clean) return null;
        const parts = clean.split(/[;,]/);
        if (parts.length !== 2) return null;
        const lat = Number(parts[0]);
        const lon = Number(parts[1]);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
        if (Math.abs(lat) > 90 || Math.abs(lon) > 180) return null;
        return [lat, lon];
      }
      function detectIntersections(path) {
        if (!path || !path.length) return [];
        const zones = [];
        if (elements.weightToggle.checked) {
          zones.push(...state.weightZones);
        }
        if (elements.platonToggle.checked) {
          zones.push(...state.platonZones);
        }
        if (!zones.length) return [];
        const hits = [];
        let traveled = 0;
        for (let i = 0; i < path.length - 1; i += 1) {
          const start = path[i];
          const end = path[i + 1];
          const segmentLength = haversineDistance(start, end);
          zones.forEach((zone) => {
            const projection = projectPointOnSegment(zone.center, start, end);
            if (projection && projection.distance <= zone.radius) {
              hits.push({
                zone,
                distance: traveled + projection.alongDistance,
                point: projection.point,
              });
            }
          });
          traveled += segmentLength;
        }
        hits.sort((a, b) => a.distance - b.distance);
        return hits;
      }

      function getOffsetPoint(routePoint, zoneCenter, distance) {
        if (!routePoint || !zoneCenter || !Number.isFinite(distance)) return null;
        const bearing = bearingBetween(zoneCenter, routePoint);
        return destinationPoint(zoneCenter, bearing, distance);
      }

      function selectEvenly(points, limit) {
        if (!points.length || limit <= 0) return [];
        if (points.length <= limit) return points;
        const result = [];
        const step = (points.length - 1) / (limit - 1);
        for (let i = 0; i < limit; i += 1) {
          const index = Math.round(i * step);
          const point = points[index];
          if (point && !result.some((p) => nearlyEqualPoints(p, point))) {
            result.push(point);
          }
        }
        return result.slice(0, limit);
      }

      function pickEvenlySpacedPoints(path, count) {
        if (!path || !path.length) return [];
        if (path.length <= count) {
          return path.slice();
        }
        const result = [];
        const step = (path.length - 1) / (count - 1);
        for (let i = 0; i < count; i += 1) {
          const index = Math.round(i * step);
          result.push(path[index]);
        }
        return result;
      }

      function nearlyEqualPoints(a, b) {
        return Math.abs(a[0] - b[0]) < 1e-4 && Math.abs(a[1] - b[1]) < 1e-4;
      }
      function updateRecommendations() {
        if (!state.routeData) return;
        const messages = [];
        const intersections = state.routeData.intersections || [];
        if (intersections.length) {
          const weightCount = intersections.filter((hit) => hit.zone.type === 'weight').length;
          const platonCount = intersections.filter((hit) => hit.zone.type === 'platon').length;
          const parts = [];
          if (weightCount) parts.push(`весовых рамок: ${weightCount}`);
          if (platonCount) parts.push(`Платон: ${platonCount}`);
          messages.push(`На маршруте обнаружено ${intersections.length} зон (${parts.join(', ')}).`);
        } else {
          messages.push('Опасных зон на маршруте не обнаружено.');
        }
        messages.push(`Протяжённость: ${formatDistance(state.routeData.distance)}, ориентировочное время: ${formatDuration(state.routeData.duration)}.`);
        if (elements.tollToggle.checked) {
          messages.push('Учтён режим избегания платных дорог (если поддерживается).');
        }
        const prev = state.routeHistory.length ? state.routeHistory[state.routeHistory.length - 1] : null;
        if (prev && prev.distance && prev.duration) {
          const diffDist = state.routeData.distance - prev.distance;
          const diffDur = state.routeData.duration - prev.duration;
          const distStr = diffDist === 0 ? 'по длине без изменений' : (diffDist > 0 ? `длиннее на ${formatDistance(Math.abs(diffDist))}` : `короче на ${formatDistance(Math.abs(diffDist))}`);
          const durStr = diffDur === 0 ? 'по времени без изменений' : (diffDur > 0 ? `дольше на ${formatDuration(Math.abs(diffDur))}` : `быстрее на ${formatDuration(Math.abs(diffDur))}`);
          messages.push(`Сравнение с предыдущим маршрутом: ${distStr}, ${durStr}.`);
        }
        state.recommendations = messages;
        elements.recommendationsList.innerHTML = messages.map((msg) => `<li>${escapeHtml(msg)}</li>`).join('');
      }

      function saveSettings() {
        try {
          const payload = {
            from: elements.fromInput.value,
            to: elements.toInput.value,
            weight: elements.weightToggle.checked,
            platon: elements.platonToggle.checked,
            toll: elements.tollToggle.checked,
          };
          localStorage.setItem('truckMapSettings', JSON.stringify(payload));
        } catch (error) {
          console.warn('Не удалось сохранить настройки', error);
        }
      }

      function restoreUI() {
        try {
          const raw = localStorage.getItem('truckMapSettings');
          if (!raw) {
            elements.weightToggle.checked = true;
            return;
          }
          const data = JSON.parse(raw);
          if (typeof data.from === 'string') elements.fromInput.value = data.from;
          if (typeof data.to === 'string') elements.toInput.value = data.to;
          elements.weightToggle.checked = data.weight !== undefined ? data.weight : true;
          if (typeof data.platon === 'boolean') elements.platonToggle.checked = data.platon;
          if (typeof data.toll === 'boolean') elements.tollToggle.checked = data.toll;
        } catch (error) {
          console.warn('Не удалось восстановить настройки', error);
          elements.weightToggle.checked = true;
        }
      }
      function formatDistance(value) {
        if (!Number.isFinite(value)) return '—';
        if (value >= 1000) {
          return `${(value / 1000).toFixed(1)} км`;
        }
        return `${Math.round(value)} м`;
      }

      function formatDuration(value) {
        if (!Number.isFinite(value)) return '—';
        const totalMinutes = Math.round(value / 60);
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        if (hours > 0) {
          return `${hours} ч ${minutes} мин`;
        }
        return `${minutes} мин`;
      }

      function formatStep(step) {
        if (!step) return 'Двигайтесь прямо';
        const maneuver = step.maneuver && (step.maneuver.instruction || step.maneuver.type);
        const base = maneuver || 'Двигайтесь';
        const name = step.name ? ` на ${step.name}` : '';
        return base + name;
      }

      function delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function escapeHtml(str) {
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      function debounce(fn, wait = 300) {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn.apply(null, args), wait);
        };
      }
      function haversineDistance(a, b) {
        const R = 6371000;
        const toRad = (deg) => deg * Math.PI / 180;
        const lat1 = toRad(a[0]);
        const lat2 = toRad(b[0]);
        const dLat = toRad(b[0] - a[0]);
        const dLon = toRad(b[1] - a[1]);
        const h = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
        return 2 * R * Math.asin(Math.sqrt(h));
      }

      function bearingBetween(a, b) {
        const toRad = (deg) => deg * Math.PI / 180;
        const lat1 = toRad(a[0]);
        const lat2 = toRad(b[0]);
        const dLon = toRad(b[1] - a[1]);
        const y = Math.sin(dLon) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
        return Math.atan2(y, x);
      }

      function destinationPoint(start, bearing, distance) {
        const R = 6371000;
        const angularDistance = distance / R;
        const lat1 = toRad(start[0]);
        const lon1 = toRad(start[1]);
        const lat2 = Math.asin(Math.sin(lat1) * Math.cos(angularDistance) + Math.cos(lat1) * Math.sin(angularDistance) * Math.cos(bearing));
        const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(angularDistance) * Math.cos(lat1), Math.cos(angularDistance) - Math.sin(lat1) * Math.sin(lat2));
        return [toDeg(lat2), normalizeLon(toDeg(lon2))];
      }

      function projectPointOnSegment(point, start, end) {
        const R = 6371000;
        const toRad = (deg) => deg * Math.PI / 180;
        const lat0 = toRad((start[0] + end[0]) / 2);
        const toXY = ([lat, lon]) => {
          const x = R * toRad(lon) * Math.cos(lat0);
          const y = R * toRad(lat);
          return { x, y };
        };
        const startXY = toXY(start);
        const endXY = toXY(end);
        const pointXY = toXY(point);
        const dx = endXY.x - startXY.x;
        const dy = endXY.y - startXY.y;
        const lenSq = dx * dx + dy * dy;
        if (lenSq === 0) {
          const distance = Math.hypot(pointXY.x - startXY.x, pointXY.y - startXY.y);
          return {
            point: start.slice(),
            distance,
            alongDistance: 0,
          };
        }
        const t = Math.max(0, Math.min(1, ((pointXY.x - startXY.x) * dx + (pointXY.y - startXY.y) * dy) / lenSq));
        const projX = startXY.x + dx * t;
        const projY = startXY.y + dy * t;
        const closestLat = toDeg(projY / R);
        const closestLon = toDeg(projX / (R * Math.cos(lat0)));
        const distance = Math.hypot(pointXY.x - projX, pointXY.y - projY);
        const alongDistance = Math.hypot(projX - startXY.x, projY - startXY.y);
        return {
          point: [closestLat, closestLon],
          distance,
          alongDistance,
        };
      }

      function toRad(deg) {
        return deg * Math.PI / 180;
      }

      function toDeg(rad) {
        return rad * 180 / Math.PI;
      }

      function normalizeLon(lon) {
        return ((lon + 540) % 360) - 180;
      }

    })();
  </script>
</body>
</html>
