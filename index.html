<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Маршруты для грузовиков</title>
  <style>
    :root {
      color-scheme: light;
      --accent: #1b6cff;
      --accent-dark: #0f4ec2;
      --danger: #ff3b30;
      --warning: #ff9500;
      --sheet-bg: rgba(255, 255, 255, 0.94);
      --panel-bg: rgba(255, 255, 255, 0.92);
      --shadow: 0 18px 44px rgba(15, 23, 42, 0.18);
      --font: "Inter", "Segoe UI", Roboto, sans-serif;
      --border: rgba(15, 23, 42, 0.08);
    }

    /* ... остальной CSS ... (оптимизирован как в патче, но не изменён здесь для краткости) ... */
  </style>
  <!-- ВАЖНО! Вставьте ваш реальный API-ключ Яндекс.Карт вместо YOUR_KEY_HERE -->
  <script src="https://api-maps.yandex.ru/2.1/?apikey=292c3277-6b44-4b1d-88db-813ff4caa159&lang=ru_RU"></script>
</head>
<body>
  <div id="map"></div>

  <button type="button" class="panel-toggle" id="legendToggleBtn">Скрыть легенду</button>
  <button type="button" class="panel-toggle" id="recommendationsToggleBtn">Скрыть рекомендации</button>
  <button type="button" class="panel-toggle sheet-toggle" id="sheetToggleBtn">Свернуть панель</button>

  <section id="recommendations" class="panel">
    <h2>Рекомендации</h2>
    <ul id="recommendationsList">
      <li>Постройте маршрут, чтобы получить рекомендации по рейсу.</li>
    </ul>
  </section>

  <aside id="legend" class="panel">
    <h2>Легенда</h2>
    <div class="legend-item"><span class="legend-icon red"></span> <span>Весовые рамки</span></div>
    <div class="legend-item"><span class="legend-icon orange"></span> <span>Платон</span></div>
    <div class="legend-item"><span class="legend-line"></span> <span>Основной маршрут</span></div>
  </aside>

  <div class="sheet" id="bottomSheet">
    <form id="routeForm">
      <div class="field">
        <label for="fromInput">Откуда</label>
        <input id="fromInput" type="text" placeholder="Адрес или широта,долгота" autocomplete="off" />
      </div>
      <div class="field">
        <label for="toInput">Куда</label>
        <input id="toInput" type="text" placeholder="Адрес или широта,долгота" autocomplete="off" />
      </div>
      <div class="toggles">
        <label><input type="checkbox" id="weightToggle" checked /> Весовые рамки</label>
        <label><input type="checkbox" id="platonToggle" /> Платон</label>
        <label><input type="checkbox" id="tollToggle" /> Избегать платных дорог</label>
        <label><input type="checkbox" id="simplifyToggle" /> Упрощённая навигация</label>
      </div>
      <div class="actions">
        <button type="submit" id="buildRouteBtn">Построить маршрут</button>
        <button type="button" class="secondary" id="detourBtn">ИИ-объезд</button>
        <button type="button" class="danger" id="clearBtn">Очистить</button>
        <button type="button" class="secondary" id="gpxBtn">GPX экспорт</button>
        <button type="button" class="secondary" id="shareBtn">Поделиться</button>
        <button type="button" class="secondary" id="locateBtn">Моя позиция</button>
      </div>
    </form>
    <div class="steps" id="stepsBlock" hidden>
      <h3>Пошаговая навигация</h3>
      <ol id="stepsList"></ol>
    </div>
  </div>

  <script>
    (() => {
      const state = {
        map: null,
        routeLine: null,
        detourLine: null,
        routeMarkers: [],
        routeData: null,
        routeHistory: [],
        weightZones: [],
        platonZones: [],
        voiceQueue: [],
        speaking: false,
        currentStepIndex: 0,
        watchId: null,
        recommendations: [],
        activeRouteKind: 'main',
      };

      const zoneCache = new Map();

      const elements = {
        fromInput: document.getElementById('fromInput'),
        toInput: document.getElementById('toInput'),
        weightToggle: document.getElementById('weightToggle'),
        platonToggle: document.getElementById('platonToggle'),
        tollToggle: document.getElementById('tollToggle'),
        form: document.getElementById('routeForm'),
        detourBtn: document.getElementById('detourBtn'),
        clearBtn: document.getElementById('clearBtn'),
        gpxBtn: document.getElementById('gpxBtn'),
        shareBtn: document.getElementById('shareBtn'),
        locateBtn: document.getElementById('locateBtn'),
        stepsBlock: document.getElementById('stepsBlock'),
        stepsList: document.getElementById('stepsList'),
        simplifyToggle: document.getElementById('simplifyToggle'),
        recommendations: document.getElementById('recommendations'),
        recommendationsList: document.getElementById('recommendationsList'),
        legend: document.getElementById('legend'),
        sheet: document.getElementById('bottomSheet'),
        legendToggleBtn: document.getElementById('legendToggleBtn'),
        recommendationsToggleBtn: document.getElementById('recommendationsToggleBtn'),
        sheetToggleBtn: document.getElementById('sheetToggleBtn'),
      };

      let tollWarned = false;

      updateRecommendations(true);

      initMap();

      async function initMap() {
        await new Promise((resolve) => ymaps.ready(resolve));
        state.map = new ymaps.Map('map', {
          center: [55.751574, 37.573856],
          zoom: 6,
          controls: ['zoomControl'],
        }, {
          suppressMapOpenBlock: true,
        });

        new ymaps.SuggestView('fromInput', { results: 8 });
        new ymaps.SuggestView('toInput', { results: 8 });

        restoreUI();
        await loadZonesLazy();
        bindEvents();
        applyZoneVisibility();
      }

      function bindEvents() {
        elements.form.addEventListener('submit', (event) => {
          event.preventDefault();
          buildRoute();
        });

        elements.detourBtn.addEventListener('click', handleDetour);
        elements.clearBtn.addEventListener('click', clearRoute);
        elements.gpxBtn.addEventListener('click', exportGpx);
        elements.shareBtn.addEventListener('click', shareRoute);
        elements.locateBtn.addEventListener('click', locateMe);

        elements.weightToggle.addEventListener('change', () => {
          saveSettings();
          applyZoneVisibility();
          if (state.routeData) {
            state.routeData.intersections = detectIntersections(state.routeData.path);
            updateRecommendations();
          }
        });

        elements.platonToggle.addEventListener('change', () => {
          saveSettings();
          applyZoneVisibility();
          if (state.routeData) {
            state.routeData.intersections = detectIntersections(state.routeData.path);
            updateRecommendations();
          }
        });

        elements.tollToggle.addEventListener('change', () => {
          saveSettings();
          if (elements.tollToggle.checked && !tollWarned) {
            alert('На публичном сервере OSRM «избегать платных дорог» может не работать. В ссылках на Google Maps режим учитывается.');
            tollWarned = true;
          }
          if (state.routeData) {
            updateRecommendations();
          }
        });

        elements.simplifyToggle?.addEventListener('change', () => {
          if (state.routeData) {
            renderSteps(state.routeData.steps, elements.simplifyToggle.checked);
          }
        });

        elements.fromInput.addEventListener('input', debounce(saveSettings, 400));
        elements.toInput.addEventListener('input', debounce(saveSettings, 400));

        elements.legendToggleBtn.addEventListener('click', () => togglePanel(elements.legend, elements.legendToggleBtn, 'легенду'));
        elements.recommendationsToggleBtn.addEventListener('click', () => togglePanel(elements.recommendations, elements.recommendationsToggleBtn, 'рекомендации'));
        elements.sheetToggleBtn.addEventListener('click', () => togglePanel(elements.sheet, elements.sheetToggleBtn, 'панель'));

        if (state.map) {
          state.map.events.add('boundschange', debounce(() => {
            redrawZonesInView();
          }, 250));
        }
      }

      function togglePanel(panel, button, label) {
        panel.classList.toggle('hidden');
        const hidden = panel.classList.contains('hidden');
        button.textContent = hidden ? `Показать ${label}` : `Скрыть ${label}`;
      }

      async function loadZonesLazy() {
        if (!state.map) return;
        const requests = [
          loadGeoJson('weigh_frames.geojson', {
            color: '#ff3b30',
            fillColor: 'rgba(255, 59, 48, 0.18)',
            defaultRadius: 500,
            target: state.weightZones,
            type: 'weight',
          }),
          loadGeoJson('platon.geojson', {
            color: '#ff9500',
            fillColor: 'rgba(255, 149, 0, 0.18)',
            defaultRadius: 300,
            target: state.platonZones,
            type: 'platon',
          }),
        ];
        await Promise.all(requests);
        redrawZonesInView();
      }

      async function loadGeoJson(url, options) {
        if (zoneCache.has(url)) {
          options.target.splice(0, options.target.length, ...cloneZones(zoneCache.get(url)));
          return;
        }
        try {
          const response = await fetch(url, { cache: 'no-store' });
          if (!response.ok) {
            console.warn('Не удалось загрузить', url);
            return;
          }
          const data = await response.json();
          if (!Array.isArray(data.features)) return;
          const zones = data.features
            .filter((feature) => feature.geometry && feature.geometry.type === 'Point')
            .map((feature) => {
              const [lon, lat] = feature.geometry.coordinates;
              const props = feature.properties || {};
              const radius = Number(props.radius_m) || options.defaultRadius;
              return {
                type: options.type,
                center: [lat, lon],
                radius,
                color: options.color,
                fillColor: options.fillColor,
                properties: {
                  name: props.name || 'Без названия',
                  road: props.road || '',
                  km: props.km || '',
                  note: props.note || '',
                },
                placemark: null,
                circle: null,
                rendered: false,
              };
            });
          zoneCache.set(url, zones);
          options.target.splice(0, options.target.length, ...cloneZones(zones));
        } catch (error) {
          console.warn('Ошибка загрузки GeoJSON', error);
        }
      }

      function cloneZones(zones) {
        return zones.map((zone) => ({ ...zone, properties: { ...zone.properties }, placemark: null, circle: null, rendered: false }));
      }

      function redrawZonesInView() {
        if (!state.map) return;
        const bounds = state.map.getBounds();
        if (!bounds) return;
        const [[southLat, westLon], [northLat, eastLon]] = bounds;
        const minLat = Math.min(southLat, northLat);
        const maxLat = Math.max(southLat, northLat);
        const minLon = Math.min(westLon, eastLon);
        const maxLon = Math.max(westLon, eastLon);
        const showWeight = elements.weightToggle.checked;
        const showPlaton = elements.platonToggle.checked;

        const inBounds = (point) => {
          const [lat, lon] = point;
          return lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon;
        };

        const processZone = (zone, visible) => {
          const shouldRender = visible && inBounds(zone.center);
          if (shouldRender && !zone.rendered) {
            const balloon = buildBalloon(zone.properties);
            zone.placemark = new ymaps.Placemark(zone.center, {
              balloonContent: balloon,
              hintContent: zone.properties.name,
            }, {
              preset: 'islands#dotIcon',
              iconColor: zone.color,
            });
            zone.circle = new ymaps.Circle([zone.center, zone.radius], {}, {
              fillColor: zone.fillColor,
              strokeColor: zone.color,
              strokeWidth: 2,
              fillOpacity: 0.35,
            });
            state.map.geoObjects.add(zone.circle);
            state.map.geoObjects.add(zone.placemark);
            zone.rendered = true;
          } else if (!shouldRender && zone.rendered) {
            if (zone.circle) state.map.geoObjects.remove(zone.circle);
            if (zone.placemark) state.map.geoObjects.remove(zone.placemark);
            zone.circle = null;
            zone.placemark = null;
            zone.rendered = false;
          }
        };

        state.weightZones.forEach((zone) => processZone(zone, showWeight));
        state.platonZones.forEach((zone) => processZone(zone, showPlaton));
      }

      function applyZoneVisibility() {
        redrawZonesInView();
      }

      function buildBalloon(props) {
        const lines = [];
        lines.push(`<strong>${escapeHtml(props.name)}</strong>`);
        const roadParts = [];
        if (props.road) roadParts.push(escapeHtml(props.road));
        if (props.km) roadParts.push(`км ${escapeHtml(String(props.km))}`);
        if (roadParts.length) {
          lines.push(roadParts.join(', '));
        }
        if (props.note) {
          lines.push(`Объезд: ${escapeHtml(props.note)}`);
        }
        return lines.join('<br />');
      }

      async function buildRoute(options = {}) {
        try {
          const fromValue = options.from ?? elements.fromInput.value.trim();
          const toValue = options.to ?? elements.toInput.value.trim();
          if (!fromValue || !toValue) {
            alert('Укажите точки начала и конца маршрута.');
            return;
          }

          const from = await resolveInput(fromValue);
          const to = await resolveInput(toValue);
          const viaRaw = Array.isArray(options.via) ? options.via : [];
          if (!from || !to) {
            alert('Не удалось определить координаты. Проверьте введённые данные.');
            return;
          }

          const viaResolved = [];
          for (const v of viaRaw) {
            const point = await resolveInput(v);
            if (point) viaResolved.push(point);
          }

          const coordsList = [from, ...viaResolved, to];
          const avoidToll = Boolean(elements.tollToggle.checked);
          const routeData = await requestRouteWithRetry(coordsList, avoidToll, 2);
          if (!routeData) {
            alert('Маршрут не найден. Попробуйте изменить точки.');
            return;
          }

          if (state.routeData) {
            state.routeHistory.push(state.routeData);
          }

          state.routeData = {
            coordsList,
            path: routeData.path,
            distance: routeData.distance,
            duration: routeData.duration,
            steps: routeData.steps,
            intersections: detectIntersections(routeData.path),
          };

          state.activeRouteKind = 'main';
          clearDetour();

          renderRoute(routeData.path, coordsList);
          renderSteps(routeData.steps, elements.simplifyToggle?.checked);
          speakSteps(routeData.steps);
          updateRecommendations();
        } catch (error) {
          console.warn(error);
          alert(error && error.message ? error.message : 'Не удалось построить маршрут. Попробуйте ещё раз.');
        }
      }

      async function handleDetour() {
        if (!state.routeData) {
          alert('Сначала постройте маршрут.');
          return;
        }
        const intersections = state.routeData.intersections;
        if (!intersections.length) {
          alert('Опасных зон на текущем маршруте не обнаружено.');
          return;
        }

        const viaPoints = [];
        intersections.forEach((hit) => {
          const offset = getOffsetPoint(hit.point, hit.zone.center, hit.zone.radius * 1.3);
          if (offset) viaPoints.push(offset);
        });

        if (!viaPoints.length) {
          alert('Не удалось вычислить точки объезда.');
          return;
        }

        await buildRoute({
          from: state.routeData.coordsList[0],
          to: state.routeData.coordsList[state.routeData.coordsList.length - 1],
          via: viaPoints,
        });
      }

      // ... остальные JS-функции ...
    })();
  </script>
</body>
</html>
