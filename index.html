<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Маршруты для грузовиков</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: "Segoe UI", Roboto, sans-serif;
      background: #fff;
    }
    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    .controls {
      position: absolute;
      top: 20px;
      left: 20px;
      display: grid;
      gap: 8px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.92);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.12);
      border-radius: 12px;
      z-index: 2000;
      width: min(320px, calc(100vw - 40px));
    }
    .controls label {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 13px;
      color: #333;
    }
    .controls input {
      padding: 10px 12px;
      border: 1px solid #d0d7de;
      border-radius: 8px;
      font-size: 15px;
    }
    .controls button {
      padding: 12px;
      border: none;
      border-radius: 8px;
      background: #0a6bff;
      color: #fff;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .controls button:hover {
      background: #0059d6;
    }
    .legend {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 14px 18px;
      background: rgba(255, 255, 255, 0.92);
      border-radius: 12px;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.12);
      font-size: 13px;
      line-height: 1.6;
      z-index: 1500;
    }
    .legend .title {
      font-weight: 700;
      margin-bottom: 6px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    .legend-dot.red { background: #ff3b30; }
    .legend-dot.orange { background: #ff9500; }
    .legend-line {
      width: 18px;
      height: 3px;
      background: #0066ff;
      border-radius: 3px;
    }
    .ymaps-suggest__container {
      z-index: 4000 !important;
    }
  </style>
  <script src="https://api-maps.yandex.ru/2.1/?apikey=YOUR_KEY_HERE&lang=ru_RU"></script>
</head>
<body>
  <div id="map"></div>
  <div class="controls" id="controls">
    <label>
      Откуда
      <input id="from" type="text" placeholder="Адрес или широта,долгота" autocomplete="off" />
    </label>
    <label>
      Куда
      <input id="to" type="text" placeholder="Адрес или широта,долгота" autocomplete="off" />
    </label>
    <button id="routeBtn" type="button">Маршрут</button>
  </div>
  <div class="legend">
    <div class="title">Условные обозначения</div>
    <div class="legend-item"><span class="legend-dot red"></span> Весовые рамки (круг 500 м)</div>
    <div class="legend-item"><span class="legend-dot orange"></span> Пункты «Платон» (круг 300 м)</div>
    <div class="legend-item"><span class="legend-line"></span> Маршрут</div>
  </div>
  <script>
    (function() {
      const state = {
        map: null,
        routeLine: null,
        routeStart: null,
        routeEnd: null,
        weightLayer: [],
        platonLayer: []
      };

      ymaps.ready(init);

      function init() {
        state.map = new ymaps.Map('map', {
          center: [55.751244, 37.618423],
          zoom: 5,
          controls: ['zoomControl']
        }, {
          suppressMapOpenBlock: true
        });

        new ymaps.SuggestView('from');
        new ymaps.SuggestView('to');

        document.getElementById('routeBtn').addEventListener('click', buildRoute);
        document.getElementById('from').addEventListener('keydown', onEnterSubmit);
        document.getElementById('to').addEventListener('keydown', onEnterSubmit);

        loadGeoJson('weigh_frames.geojson', {
          color: '#ff3b30',
          fillColor: 'rgba(255, 59, 48, 0.15)',
          defaultRadius: 500,
          collection: state.weightLayer
        });
        loadGeoJson('platon.geojson', {
          color: '#ff9500',
          fillColor: 'rgba(255, 149, 0, 0.15)',
          defaultRadius: 300,
          collection: state.platonLayer
        });
      }

      function onEnterSubmit(event) {
        if (event.key === 'Enter') {
          event.preventDefault();
          buildRoute();
        }
      }

      function parseLatLon(value) {
        if (!value) return null;
        const match = value.trim().match(/^\s*(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*$/);
        if (!match) return null;
        const lat = parseFloat(match[1]);
        const lon = parseFloat(match[2]);
        if (!isFinite(lat) || !isFinite(lon)) return null;
        if (Math.abs(lat) > 90 || Math.abs(lon) > 180) return null;
        return [lat, lon];
      }

      function geocodeInput(value) {
        const coords = parseLatLon(value);
        if (coords) {
          return Promise.resolve(coords);
        }
        return ymaps.geocode(value, { results: 1 }).then(function(res) {
          const first = res.geoObjects.get(0);
          if (!first) {
            throw new Error('Адрес не найден: ' + value);
          }
          return first.geometry.getCoordinates();
        });
      }

      async function buildRoute() {
        const fromInput = document.getElementById('from').value.trim();
        const toInput = document.getElementById('to').value.trim();

        if (!fromInput || !toInput) {
          alert('Укажите оба адреса.');
          return;
        }

        try {
          const [fromCoords, toCoords] = await Promise.all([
            geocodeInput(fromInput),
            geocodeInput(toInput)
          ]);

          await requestRoute(fromCoords, toCoords);
        } catch (error) {
          console.error(error);
          alert(error.message || 'Не удалось построить маршрут.');
        }
      }

      async function requestRoute(fromCoords, toCoords) {
        const url = buildOsrmUrl(fromCoords, toCoords);
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('Маршрутный сервис недоступен.');
        }
        const data = await response.json();
        if (!data.routes || !data.routes.length) {
          throw new Error('Маршрут не найден.');
        }

        const geometry = data.routes[0].geometry.coordinates;
        const path = geometry.map(function(coord) {
          return [coord[1], coord[0]];
        });

        drawRoute(path, fromCoords, toCoords);
      }

      function buildOsrmUrl(fromCoords, toCoords) {
        const fromLonLat = [fromCoords[1], fromCoords[0]].join(',');
        const toLonLat = [toCoords[1], toCoords[0]].join(',');
        return 'https://router.project-osrm.org/route/v1/driving/' + fromLonLat + ';' + toLonLat + '?overview=full&geometries=geojson';
      }

      function drawRoute(path, fromCoords, toCoords) {
        if (state.routeLine) {
          state.map.geoObjects.remove(state.routeLine);
        }
        if (state.routeStart) {
          state.map.geoObjects.remove(state.routeStart);
          state.map.geoObjects.remove(state.routeEnd);
        }

        state.routeLine = new ymaps.Polyline(path, {}, {
          strokeColor: '#0066ff',
          strokeWidth: 5,
          strokeOpacity: 0.9
        });

        state.routeStart = new ymaps.Placemark(fromCoords, { iconCaption: 'Старт' }, { preset: 'islands#blueCircleIcon' });
        state.routeEnd = new ymaps.Placemark(toCoords, { iconCaption: 'Финиш' }, { preset: 'islands#blueCircleIcon' });

        state.map.geoObjects.add(state.routeLine);
        state.map.geoObjects.add(state.routeStart);
        state.map.geoObjects.add(state.routeEnd);

        const bounds = state.routeLine.geometry.getBounds();
        if (bounds) {
          state.map.setBounds(bounds, { checkZoomRange: true, zoomMargin: 40 });
        }
      }

      async function loadGeoJson(url, options) {
        try {
          const response = await fetch(url, { cache: 'no-store' });
          if (!response.ok) return;
          const data = await response.json();
          if (!data.features) return;
          data.features.forEach(function(feature) {
            if (!feature.geometry || feature.geometry.type !== 'Point') return;
            const coords = feature.geometry.coordinates;
            const center = [coords[1], coords[0]];
            const props = feature.properties || {};
            const radius = Number(props.radius_m) || options.defaultRadius;
            const balloon = formatBalloon(props);

            const placemark = new ymaps.Placemark(center, {
              balloonContent: balloon,
              hintContent: props.name || ''
            }, {
              preset: 'islands#dotIcon',
              iconColor: options.color,
              zIndex: 1500
            });
            const circle = new ymaps.Circle([center, radius], {
              balloonContent: balloon,
              hintContent: props.name || ''
            }, {
              fillColor: options.fillColor,
              strokeColor: options.color,
              strokeOpacity: 0.6,
              fillOpacity: 0.4,
              strokeWidth: 2,
              zIndex: 1200
            });

            state.map.geoObjects.add(circle);
            state.map.geoObjects.add(placemark);

            options.collection.push({ placemark, circle });
          });
        } catch (error) {
          console.warn('Не удалось загрузить ' + url, error);
        }
      }

      function formatBalloon(props) {
        const parts = [];
        if (props.name) {
          parts.push('<strong>' + escapeHtml(props.name) + '</strong>');
        }
        if (props.road || props.km) {
          const road = props.road ? escapeHtml(props.road) : '';
          const km = props.km ? ' ' + escapeHtml(props.km) : '';
          parts.push(road + km);
        }
        if (props.note) {
          parts.push(escapeHtml(props.note));
        }
        return parts.join('<br>');
      }

      function escapeHtml(text) {
        return String(text)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }
    })();
  </script>
</body>
</html>
